{"version":3,"sources":["services/SPTermStorePickerService.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,8CAA8F;AAC9F,8DAA0E;AAK1E,+EAAuE;AACvE,gEAAwD;AAExD,iDAAgD;AAGhD;;GAEG;AACH;IAME;;OAEG;IACH,kCAAoB,KAA2B,EAAU,OAA2C;QAAhF,UAAK,GAAL,KAAK,CAAsB;QAAU,YAAO,GAAP,OAAO,CAAoC;QAClG,EAAE,CAAC,CAAC,6BAAW,CAAC,IAAI,KAAK,iCAAe,CAAC,KAAK,CAAC,CAAC,CAAC;YAC/C,CAAC;gBACC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,GAAG,mCAAmC,CAAC;gBACvG,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,GAAI,uDAAuD,CAAC;YAClI,CAAC;QACH,CAAC;IACH,CAAC;IAEY,gDAAa,GAA1B,UAA2B,MAAc;;;;;;wBACvC,EAAE,CAAC,CAAC,6BAAW,CAAC,IAAI,KAAK,iCAAe,CAAC,KAAK,CAAC,CAAC,CAAC;4BAC/C,mEAAmE;4BACnE,MAAM,gBAAC,IAAI,EAAC;wBACd,CAAC;wBAEG,MAAM,GAAG,IAAI,CAAC;;;;wBAEV,IAAI,GAAG,w/BAAo7B,MAAM,+DAA4D,CAAC;wBAE9/B,UAAU,GAAG,IAAI,OAAO,EAAE,CAAC;wBACjC,UAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;wBAChD,UAAU,CAAC,MAAM,CAAC,cAAc,EAAE,iBAAiB,CAAC,CAAC;wBAE/C,eAAe,GAAyB;4BAC5C,OAAO,EAAE,UAAU;4BACnB,IAAI,EAAE,IAAI;yBACX,CAAC;wBAEiB,qBAAM,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,sBAAY,CAAC,cAAc,CAAC,EAAE,EAAE,eAAe,CAAC,EAAA;;wBAAzH,UAAU,GAAG,SAA4G;wBAC5G,qBAAM,UAAU,CAAC,IAAI,EAAE,EAAA;;wBAApC,UAAU,GAAG,SAAuB;wBAEtC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,YAAY,IAAI,kBAAkB,EAApC,CAAoC,CAAC,CAAC;wBACtE,EAAE,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC;4BACrD,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,GAAG,CAAC,UAAA,SAAS,IAAI,OAAA,SAAS,CAAC,KAAK,EAAf,CAAe,CAAC,CAAC;wBACvE,CAAC;;;;wBAED,MAAM,GAAG,IAAI,CAAC;wBACd,OAAO,CAAC,GAAG,CAAC,OAAK,CAAC,OAAO,CAAC,CAAC;;4BAE7B,sBAAO,MAAM,EAAC;;;;KACf;IAED;;OAEG;IACI,gDAAa,GAApB;QAAA,iBAwDC;QAvDC,EAAE,CAAC,CAAC,6BAAW,CAAC,IAAI,KAAK,iCAAe,CAAC,KAAK,CAAC,CAAC,CAAC;YAC/C,mEAAmE;YACnE,MAAM,CAAC,IAAI,CAAC,qBAAqB,EAAE,CAAC;QACtC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,sDAAsD;YACtD,IAAM,IAAI,GAAG,m8CAAm8C,CAAC;YAEj9C,IAAM,UAAU,GAAG,IAAI,OAAO,EAAE,CAAC;YACjC,UAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;YAChD,UAAU,CAAC,MAAM,CAAC,cAAc,EAAE,iBAAiB,CAAC,CAAC;YAErD,IAAM,eAAe,GAAyB;gBAC5C,OAAO,EAAE,UAAU;gBACnB,IAAI,EAAE,IAAI;aACX,CAAC;YAEF,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,sBAAY,CAAC,cAAc,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC,IAAI,CAAC,UAAC,eAAqC;gBACvJ,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,UAAC,mBAAwB;oBAC1D,oBAAoB;oBACpB,IAAI,eAAe,GAAiB,mBAAmB,CAAC,MAAM,CAAC,UAAC,CAA2B,IAAK,OAAA,CAAC,CAAC,cAAc,CAAC,KAAK,uBAAuB,EAA7C,CAA6C,CAAC,CAAC;oBAC/I,oCAAoC;oBACpC,EAAE,CAAC,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;wBAC/B,yDAAyD;wBACzD,EAAE,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC;4BAC/B,MAAM,CAAC,eAAe,CAAC,GAAG,CAAC,UAAA,SAAS;gCAClC,IAAI,UAAU,GAAG,SAAS,CAAC,MAAM,CAAC,aAAa,CAAC;gCAEhD,gEAAgE;gCAChE,EAAE,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC;oCAC/B,IAAM,iBAAe,GAAG,KAAI,CAAC,KAAK,CAAC,eAAe,CAAC;oCACnD,UAAU,GAAG,UAAU,CAAC,GAAG,CAAC,UAAC,KAAa;wCACxC,KAAK,CAAC,QAAQ,CAAC,aAAa,GAAG,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,CAAC,UAAC,OAAiB,IAAK,OAAA,OAAO,CAAC,IAAI,KAAK,iBAAe,IAAI,KAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,WAAW,EAAE,KAAK,KAAI,CAAC,SAAS,CAAC,iBAAe,CAAC,CAAC,WAAW,EAAE,EAA9H,CAA8H,CAAC,CAAC;wCAC1N,MAAM,CAAC,KAAK,CAAC;oCACf,CAAC,CAAC,CAAC;gCACL,CAAC;gCAED,+BAA+B;gCAC/B,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,CAAC,KAAK,CAAC,aAAa,EAApB,CAAoB,CAAC,CAAC;gCAE9D,0BAA0B;gCAC1B,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,UAAC,KAAa,IAAK,OAAA,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAvC,CAAuC,CAAC,CAAC;gCAE3F,qBAAqB;gCACrB,SAAS,CAAC,MAAM,CAAC,aAAa,GAAG,UAAU,CAAC;gCAC5C,MAAM,CAAC,SAAS,CAAC;4BACnB,CAAC,CAAC,CAAC;wBACL,CAAC;wBAED,gCAAgC;wBAChC,MAAM,CAAC,eAAe,CAAC;oBACzB,CAAC;oBACD,MAAM,CAAC,EAAE,CAAC;gBACZ,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED;;OAEG;IACU,6CAAU,GAAvB;;;;;;6BACM,CAAA,6BAAW,CAAC,IAAI,KAAK,iCAAe,CAAC,KAAK,CAAA,EAA1C,wBAA0C;wBACxB,qBAAM,sCAAyB,CAAC,WAAW,EAAE,EAAA;;wBAA3D,WAAW,GAAG,SAA6C;wBACjE,sBAAO,WAAW,EAAC;4BAED,qBAAM,IAAI,CAAC,aAAa,EAAE,EAAA;;wBAAtC,SAAS,GAAG,SAA0B;wBAC5C,sBAAO,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,EAAC;;;;KAEnE;IAED;;;OAGG;IACU,8CAAW,GAAxB,UAAyB,OAAe,EAAE,kBAA4B,EAAE,8BAAwC;;;;;;;6BAC1G,CAAA,6BAAW,CAAC,IAAI,KAAK,iCAAe,CAAC,KAAK,CAAA,EAA1C,wBAA0C;wBAC5C,mEAAmE;wBACnE,sBAAO,IAAI,CAAC,eAAe,EAAE,EAAC;;wBAE1B,cAAoB,OAAO,CAAC;6BAE5B,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,EAArB,wBAAqB;wBAEL,qBAAM,IAAI,CAAC,aAAa,EAAE,EAAA;;wBAAtC,SAAS,GAAG,SAA0B;wBAEtC,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;wBAC1D,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;4BAChB,WAAS,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;wBAC7C,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACN,MAAM,gBAAC,IAAI,EAAC;wBACd,CAAC;;;wBAGC,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,WAAS,CAAC,CAAC;wBAE9C,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;4BACf,MAAM,gBAAC,UAAU,EAAC;wBACpB,CAAC;wBAGK,IAAI,GAAG,2nDAAugD,WAAS,sHAA6G,CAAC;wBAGroD,UAAU,GAAG,IAAI,OAAO,EAAE,CAAC;wBACjC,UAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;wBAChD,UAAU,CAAC,MAAM,CAAC,cAAc,EAAE,iBAAiB,CAAC,CAAC;wBAE/C,eAAe,GAAyB;4BAC5C,OAAO,EAAE,UAAU;4BACnB,IAAI,EAAE,IAAI;yBACX,CAAC;wBAEF,sBAAO,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE,sBAAY,CAAC,cAAc,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC,IAAI,CAAC,UAAC,eAAqC;gCACvJ,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,UAAC,mBAAwB;oCAC1D,IAAM,uBAAuB,GAAe,mBAAmB,CAAC,MAAM,CAAC,UAAC,CAA2B,IAAK,OAAA,CAAC,CAAC,cAAc,CAAC,KAAK,qBAAqB,EAA3C,CAA2C,CAAC,CAAC;oCAErJ,EAAE,CAAC,CAAC,uBAAuB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;wCACvC,IAAI,sBAAsB,GAAG,uBAAuB,CAAC,CAAC,CAAC,CAAC;wCACxD,sBAAsB,CAAC,KAAK,GAAG,EAAE,CAAC;wCAClC,uCAAuC;wCACvC,IAAM,oBAAoB,GAAa,mBAAmB,CAAC,MAAM,CAAC,UAAC,CAA2B,IAAK,OAAA,CAAC,CAAC,cAAc,CAAC,KAAK,4BAA4B,EAAlD,CAAkD,CAAC,CAAC;wCACvJ,EAAE,CAAC,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;4CACpC,qBAAqB;4CACrB,IAAI,KAAK,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;4CAElD,EAAE,CAAC,CAAC,kBAAkB,KAAK,IAAI,CAAC,CAAC,CAAC;gDAChC,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,cAAc,CAAC,KAAK,KAAK,EAA3B,CAA2B,CAAC,CAAC;4CACzD,CAAC;4CAED,EAAE,CAAC,CAAC,8BAA8B,KAAK,IAAI,CAAC,CAAC,CAAC;gDAC5C,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,uBAAuB,CAAC,KAAK,IAAI,EAAnC,CAAmC,CAAC,CAAC;4CACjE,CAAC;4CAED,+CAA+C;4CAC/C,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI;gDACpB,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;oDAChB,IAAI,CAAC,oBAAoB,GAAG,CAAC,sBAAsB,CAAC,eAAe,CAAC,GAAG,sBAAsB,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gDACjK,CAAC;gDAAC,IAAI,CAAC,CAAC;oDACN,IAAI,CAAC,oBAAoB,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gDACjJ,CAAC;gDACD,IAAI,CAAC,EAAE,GAAG,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gDAClC,IAAI,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;gDACtD,IAAI,CAAC,OAAO,GAAG,EAAE,EAAE,EAAE,KAAI,CAAC,SAAS,CAAC,sBAAsB,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,sBAAsB,CAAC,IAAI,EAAE,CAAC;gDACpG,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;oDACnB,IAAI,CAAC,QAAQ,GAAG,KAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;gDACpD,CAAC;gDACD,MAAM,CAAC,IAAI,CAAC;4CACd,CAAC,CAAC,CAAC;4CACH,sCAAsC;4CACtC,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gDACrB,+CAA+C;gDAC/C,KAAK,GAAG,KAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gDAC9B,sBAAsB,CAAC,KAAK,GAAG,KAAK,CAAC;4CACvC,CAAC;wCACH,CAAC;wCAED,cAAc,CAAC,OAAO,CAAC,WAAS,EAAE,IAAI,CAAC,SAAS,CAAC,sBAAsB,CAAC,CAAC,CAAC;wCAC1E,MAAM,CAAC,sBAAsB,CAAC;oCAChC,CAAC;oCACD,MAAM,CAAC,IAAI,CAAC;gCACd,CAAC,CAAC,CAAC;4BACL,CAAC,CAAC,EAAC;;;;KAEN;IAED;;;;OAIG;IACK,+CAAY,GAApB,UAAqB,SAAuB,EAAE,WAAmB;QAC/D,EAAE,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,IAAI,WAAW,CAAC,CAAC,CAAC;YACrD,2BAA2B;YAC3B,IAAM,EAAE,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;YACxB,0CAA0C;YAC1C,EAAE,CAAC,CAAC,EAAE,CAAC,MAAM,IAAI,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC;gBACzC,GAAG,CAAC,CAAgB,UAAuB,EAAvB,KAAA,EAAE,CAAC,MAAM,CAAC,aAAa,EAAvB,cAAuB,EAAvB,IAAuB;oBAAtC,IAAM,KAAK,SAAA;oBACd,wCAAwC;oBACxC,EAAE,CAAC,CAAC,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC;wBACnD,GAAG,CAAC,CAAkB,UAA4B,EAA5B,KAAA,KAAK,CAAC,QAAQ,CAAC,aAAa,EAA5B,cAA4B,EAA5B,IAA4B;4BAA7C,IAAM,OAAO,SAAA;4BAChB,iCAAiC;4BACjC,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,KAAK,WAAW,CAAC,CAAC,CAAC;gCACjC,MAAM,CAAC,OAAO,CAAC;4BACjB,CAAC;yBACF;oBACH,CAAC;iBACF;YACH,CAAC;QACH,CAAC;QAED,MAAM,CAAC,IAAI,CAAC;IACd,CAAC;IAGD;;;OAGG;IACI,oDAAiB,GAAxB,UAAyB,UAAkB;QACzC,EAAE,CAAC,CAAC,6BAAW,CAAC,IAAI,KAAK,iCAAe,CAAC,KAAK,CAAC,CAAC,CAAC;YAC/C,mEAAmE;YACnE,MAAM,CAAC,sCAAyB,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;QACjE,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;QAC/C,CAAC;IACH,CAAC;IAEO,+CAAY,GAApB,UAAqB,MAAM;QACzB,IAAI,KAAK,GAAG,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAC3C,EAAE,CAAC,CAAC,KAAK,CAAC;YACR,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QAC3B,IAAI;YACF,MAAM,CAAC,IAAI,CAAC;IAChB,CAAC;IAEO,0DAAuB,GAA/B,UAAgC,KAAK,EAAE,UAAU;QAC/C,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACV,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,UAAC,CAAC,IAAO,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtG,CAAC;QACD,IAAI;YACF,MAAM,CAAC,EAAE,CAAC;IACd,CAAC;IAEY,sDAAmB,GAAhC,UAAiC,UAAkB,EAAE,MAAc;;;;;;6BAC7D,CAAA,6BAAW,CAAC,IAAI,KAAK,iCAAe,CAAC,KAAK,CAAA,EAA1C,wBAA0C;wBAC5C,mEAAmE;wBACnE,sBAAO,sCAAyB,CAAC,iBAAiB,CAAC,UAAU,CAAC,EAAC;;wBAE3D,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;6BACvC,UAAU,EAAV,wBAAU;wBACZ,sBAAO,IAAI,CAAC,uBAAuB,CAAC,UAAU,EAAE,UAAU,CAAC,EAAC;;wBAGtD,KAIF,IAAI,CAAC,KAAK,EAHZ,eAAe,qBAAA,EACf,kBAAkB,wBAAA,EAClB,8BAA8B,oCAAA,CACjB;wBAED,qBAAM,IAAI,CAAC,qBAAqB,CAC5C,eAAe,EACf,MAAM,EACN,kBAAkB,EAClB,8BAA8B,CAAC,EAAA;;wBAJ3B,KAAK,GAAG,SAImB;wBAEjC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;4BACV,MAAM,gBAAC,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,UAAU,CAAC,EAAC;wBACzD,CAAC;;4BAGH,sBAAO,IAAI,EAAC;;;;KAEf;IAED;;OAEG;IACU,wDAAqB,GAAlC,UAAmC,eAAuB,EAAE,QAAgB,EAAE,kBAA4B,EAAE,8BAAwC;;;;;;;wBAE9I,WAAW,GAAkB,EAAE,CAAC;6BAEhC,CAAA,6BAAW,CAAC,IAAI,KAAK,iCAAe,CAAC,KAAK,CAAA,EAA1C,wBAA0C;wBAEhC,qBAAM,IAAI,CAAC,uBAAuB,EAAE,EAAA;;wBAA5C,KAAK,GAAG,SAAoC;wBAChD,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI;4BAChB,WAAW,CAAC,IAAI,CAAC,KAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC;wBACvD,CAAC,CAAC,CAAC;;;wBAEG,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;wBAC/C,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;4BACf,MAAM,gBAAC,UAAU,EAAC;wBACpB,CAAC;wBAEa,qBAAM,IAAI,CAAC,WAAW,CAAC,eAAe,EAAE,kBAAkB,EAAE,8BAA8B,CAAC,EAAA;;wBAArG,OAAO,GAAG,SAA2F;wBACrG,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC;wBAC1B,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;4BACP,eAAa,KAAK,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,EAAE,CAAC,WAAW,EAAE,KAAK,QAAQ,CAAC,WAAW,EAAE,EAA7C,CAA6C,CAAC,CAAC,KAAK,EAAE,CAAC;4BAC5F,EAAE,CAAC,CAAC,YAAU,CAAC,CAAC,CAAC;gCAET,mBAAoB,YAAU,CAAC,UAAU,MAAG,CAAC;gCAC7C,WAAW,GAAY,KAAK,CAAC,MAAM,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,EAAE,gBAAc,CAAC,MAAM,CAAC,KAAK,gBAAc,IAAI,CAAC,CAAC,EAAE,KAAK,YAAU,CAAC,EAAE,EAA7F,CAA6F,CAAC,CAAC;gCAE9I,WAAW,CAAC,OAAO,CAAC,UAAA,IAAI;oCACtB,WAAW,CAAC,IAAI,CAAC,KAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC;gCACvD,CAAC,CAAC,CAAC;gCAEH,cAAc,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;4BAChE,CAAC;wBACH,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACN,KAAK,CAAC,OAAO,CAAC,UAAA,IAAI;gCAChB,WAAW,CAAC,IAAI,CAAC,KAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,CAAC;4BACvD,CAAC,CAAC,CAAC;wBACL,CAAC;;4BAGH,sBAAO,WAAW,EAAC;;;;KACpB;IAED;;;;SAIK;IACG,uDAAoB,GAA5B,UAA6B,UAAkB;QAA/C,iBAuEC;QAtEC,EAAE,CAAC,CAAC,6BAAW,CAAC,IAAI,KAAK,iCAAe,CAAC,KAAK,CAAC,CAAC,CAAC;YAC/C,mEAAmE;YACnE,MAAM,CAAC,sCAAyB,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;QACjE,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,IAAI,OAAO,CAAgB,UAAA,OAAO;gBACvC,KAAI,CAAC,aAAa,EAAE,CAAC,IAAI,CAAC,UAAA,SAAS;oBACjC,IAAI,SAAS,GAAG,KAAI,CAAC,KAAK,CAAC,eAAe,CAAC;oBAC3C,EAAE,CAAC,CAAC,CAAC,KAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;wBAC5B,2CAA2C;wBAC3C,IAAM,WAAW,GAAG,KAAI,CAAC,YAAY,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;wBAC5D,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;4BAChB,SAAS,GAAG,KAAI,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;wBAC7C,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACN,OAAO,CAAC,IAAI,CAAC,CAAC;4BACd,MAAM,CAAC;wBACT,CAAC;oBACH,CAAC;oBACD,EAAE,CAAC,CAAC,SAAS,KAAK,SAAS,IAAI,SAAS,CAAC,MAAM,KAAM,CAAC,CAAC,CAAC,CAAC;wBACvD,OAAO,CAAC,IAAI,CAAC,CAAC;wBACd,MAAM,CAAC;oBACT,CAAC;oBAED,IAAI,IAAI,GAAG;wBACT,KAAK,EAAE,UAAU;wBACjB,IAAI,EAAG,KAAI,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,QAAQ;wBAC5C,OAAO,EAAE,KAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;wBACxC,WAAW,EAAE,SAAS;wBACtB,QAAQ,EAAE,KAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,KAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,qBAAS;wBAC/D,gBAAgB,EAAE,KAAK;wBACvB,cAAc,EAAE,KAAK;wBACrB,oBAAoB,EAAE,KAAI,CAAC,KAAK,CAAC,8BAA8B,KAAK,IAAI;wBACxE,mBAAmB,EAAE,KAAI,CAAC,KAAK,CAAC,kBAAkB,KAAK,IAAI;wBAC3D,UAAU,EAAE,KAAK;wBACjB,iBAAiB,EAAE,KAAK;wBACxB,cAAc,EAAE,KAAK;wBACrB,eAAe,EAAE,qBAAS;qBAC3B,CAAC;oBAEF,IAAM,UAAU,GAAG,IAAI,OAAO,EAAE,CAAC;oBACjC,UAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;oBAChD,UAAU,CAAC,MAAM,CAAC,cAAc,EAAE,kBAAkB,CAAC,CAAC;oBAEtD,IAAM,eAAe,GAAyB;wBAC5C,OAAO,EAAE,UAAU;wBACnB,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;qBAC3B,CAAC;oBAGF,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,KAAI,CAAC,oBAAoB,EAAE,sBAAY,CAAC,cAAc,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC,IAAI,CAAC,UAAC,eAAqC;wBAC3J,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,UAAC,mBAAwB;4BAC1D,IAAM,MAAM,GAAG,mBAAmB,CAAC,CAAC,CAAC,MAAM,CAAC;4BAC5C,EAAE,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gCAChC,uCAAuC;gCACvC,IAAM,KAAK,GAAmB,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;gCACpD,EAAE,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oCACrB,qBAAqB;oCAErB,IAAI,WAAW,GAAkB,KAAK,CAAC,GAAG,CAAC,UAAC,IAAkB,IAAK,OAAA,KAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC,EAAzC,CAAyC,CAAC,CAAC;oCAC9G,OAAO,CAAC,WAAW,CAAC,CAAC;oCACrB,MAAM,CAAC;gCACT,CAAC;4BAEH,CAAC;4BAED,OAAO,CAAC,EAAE,CAAC,CAAC;wBACd,CAAC,CAAC,CAAC;oBACL,CAAC,CAAC,CAAC;gBACL,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAEO,yCAAM,GAAd,UAAe,OAAe;QAC5B,MAAM,CAAC,+EAA+E,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACvG,CAAC;IAED;;;;OAIG;IACK,4CAAS,GAAjB,UAAkB,KAAc;QAC9B,yBAAyB;QACzB,IAAI,aAAa,GAAY,EAAE,CAAC;QAChC,IAAI,WAAW,GAAG,IAAI,CAAC;QACvB,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,OAAO,WAAW,EAAE,CAAC;YACnB,kCAAkC;YAClC,IAAI,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,SAAS,KAAK,SAAS,EAA5B,CAA4B,CAAC,CAAC;YACnE,EAAE,CAAC,CAAC,SAAS,IAAI,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBACtC,SAAS,GAAG,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;gBAEhD,EAAE,CAAC,CAAC,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC;oBACpB,SAAS,GAAG,SAAS,CAAC,OAAO,EAAE,CAAC;4CACrB,QAAQ;wBACjB,IAAM,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;wBAChD,0CAA0C;wBAC1C,QAAQ,CAAC,GAAG,EAAE,CAAC;wBACf,4CAA4C;wBAC5C,IAAM,GAAG,GAAG,4BAAS,CAAC,aAAa,EAAE,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,UAAU,KAAK,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,EAAtC,CAAsC,CAAC,CAAC;wBACrF,EAAE,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;4BACf,aAAa,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;wBAC7C,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACN,2DAA2D;4BAC3D,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;wBAC/B,CAAC;oBACH,CAAC;oBAZD,GAAG,CAAC,CAAmB,UAAS,EAAT,uBAAS,EAAT,uBAAS,EAAT,IAAS;wBAA3B,IAAM,QAAQ,kBAAA;gCAAR,QAAQ;qBAYlB;gBACH,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,aAAa,GAAG,SAAS,CAAC;gBAC5B,CAAC;gBAED,EAAE,SAAS,CAAC;YACd,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,WAAW,GAAG,KAAK,CAAC;YACtB,CAAC;QACH,CAAC;QACD,MAAM,CAAC,aAAa,CAAC;IACvB,CAAC;IAED;;;;;OAKG;IACK,iDAAc,GAAtB,UAAuB,CAAQ,EAAE,CAAQ;QACvC,EAAE,CAAC,CAAC,CAAC,CAAC,oBAAoB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YAClC,EAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;gBAC5D,MAAM,CAAC,CAAC,CAAC,CAAC;YACZ,CAAC;YACD,EAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;gBAC5D,MAAM,CAAC,CAAC,CAAC;YACX,CAAC;YACD,MAAM,CAAC,CAAC,CAAC;QACX,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,EAAE,CAAC,CAAC,CAAC,CAAC,oBAAoB,GAAG,CAAC,CAAC,oBAAoB,CAAC,CAAC,CAAC;gBACpD,MAAM,CAAC,CAAC,CAAC,CAAC;YACZ,CAAC;YACD,EAAE,CAAC,CAAC,CAAC,CAAC,oBAAoB,GAAG,CAAC,CAAC,oBAAoB,CAAC,CAAC,CAAC;gBACpD,MAAM,CAAC,CAAC,CAAC;YACX,CAAC;YACD,MAAM,CAAC,CAAC,CAAC;QACX,CAAC;IACH,CAAC;IAED;;;OAGG;IACI,4CAAS,GAAhB,UAAiB,IAAY;QAC3B,EAAE,CAAC,CAAC,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;QACtE,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,EAAE,CAAC;QACZ,CAAC;IACH,CAAC;IAED;;OAEG;IACK,wDAAqB,GAA7B;QACE,MAAM,CAAC,sCAAyB,CAAC,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,UAAC,IAAI;YACjG,MAAM,CAAC,IAAI,CAAC;QACd,CAAC,CAA0B,CAAC;IAC9B,CAAC;IAED;;OAEG;IACK,kDAAe,GAAvB;QACE,MAAM,CAAC,sCAAyB,CAAC,WAAW,EAAE,CAAC,IAAI,CAAC,UAAC,IAAI;YACvD,MAAM,CAAC,IAAI,CAAC;QACd,CAAC,CAAsB,CAAC;IAC1B,CAAC;IAED;;OAEG;IACK,0DAAuB,GAA/B;QACE,MAAM,CAAC,sCAAyB,CAAC,qBAAqB,EAAE,CAAC,IAAI,CAAC,UAAC,IAAI;YACjE,MAAM,CAAC,IAAI,CAAC;QACd,CAAC,CAAqB,CAAC;IACzB,CAAC;IAEO,0DAAuB,GAA/B,UAAgC,IAAW;QACzC,MAAM,CAAC;YACL,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC;YAC5B,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,IAAI,EAAE,IAAI,CAAC,UAAU;YACrB,OAAO,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;YACxC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI;SAC/B,CAAC;IACJ,CAAC;IAEO,iEAA8B,GAAtC,UAAuC,IAAkB;QACvD,IAAI,IAAI,GAAW,EAAE,CAAC;QACtB,IAAI,WAAW,GAAW,EAAE,CAAC;QAC7B,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YACxC,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YACrE,IAAM,aAAa,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC1C,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,GAAI,IAAI,CAAC,YAAY,CAAC;YAC1D,WAAW,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;QACjC,CAAC;QACD,MAAM,CAAC;YACL,GAAG,EAAE,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC;YAC5B,IAAI,EAAE,IAAI,CAAC,YAAY;YACvB,IAAI,EAAE,IAAI;YACV,OAAO,EAAE,qBAAS;YAClB,WAAW,EAAE,WAAW;SACzB,CAAC;IACJ,CAAC;IACH,+BAAC;AAAD,CA1jBA,AA0jBC,IAAA","file":"services/SPTermStorePickerService.js","sourcesContent":["/**\n * DISCLAIMER\n *\n * As there is not yet an OData end-point for managed metadata, this service makes use of the ProcessQuery end-points.\n * The service will get updated once the APIs are in place for managing managed metadata.\n */\n\nimport { SPHttpClient, SPHttpClientResponse, ISPHttpClientOptions } from '@microsoft/sp-http';\nimport { Environment, EnvironmentType } from '@microsoft/sp-core-library';\nimport { IWebPartContext } from '@microsoft/sp-webpart-base';\nimport { ITaxonomyPickerProps } from '../controls/taxonomyPicker/ITaxonomyPicker';\nimport { IPickerTerm } from '../controls/taxonomyPicker/ITermPicker';\nimport { ITermStore, ITerms, ITerm, IGroup, ITermSet, ISuggestTerm } from './ISPTermStorePickerService';\nimport SPTermStoreMockHttpClient from './SPTermStorePickerMockService';\nimport { findIndex } from '@microsoft/sp-lodash-subset';\nimport { ExtensionContext } from '@microsoft/sp-extension-base';\nimport { EmptyGuid } from '../common/Constants';\n\n\n/**\n * Service implementation to manage term stores in SharePoint\n */\nexport default class SPTermStorePickerService {\n  private taxonomySession: string;\n  private formDigest: string;\n  private clientServiceUrl: string;\n  private suggestionServiceUrl: string;\n\n  /**\n   * Service constructor\n   */\n  constructor(private props: ITaxonomyPickerProps, private context: IWebPartContext | ExtensionContext) {\n    if (Environment.type !== EnvironmentType.Local) {\n      {\n        this.clientServiceUrl = this.context.pageContext.web.absoluteUrl + '/_vti_bin/client.svc/ProcessQuery';\n        this.suggestionServiceUrl = this.context.pageContext.web.absoluteUrl + \t\"/_vti_bin/TaxonomyInternalService.json/GetSuggestions\";\n      }\n    }\n  }\n\n  public async getTermLabels(termId: string): Promise<string[]> {\n    if (Environment.type === EnvironmentType.Local) {\n      // If the running environment is local, load the data from the mock\n      return null;\n    }\n\n    let result = null;\n    try {\n      const data = `<Request AddExpandoFieldTypeSuffix=\"true\" SchemaVersion=\"15.0.0.0\" LibraryVersion=\"16.0.0.0\" ApplicationName=\".NET Library\" xmlns=\"http://schemas.microsoft.com/sharepoint/clientquery/2009\"><Actions><ObjectPath Id=\"8\" ObjectPathId=\"7\" /><ObjectIdentityQuery Id=\"9\" ObjectPathId=\"7\" /><ObjectPath Id=\"11\" ObjectPathId=\"10\" /><ObjectIdentityQuery Id=\"12\" ObjectPathId=\"10\" /><ObjectPath Id=\"14\" ObjectPathId=\"13\" /><ObjectIdentityQuery Id=\"15\" ObjectPathId=\"13\" /><Query Id=\"16\" ObjectPathId=\"13\"><Query SelectAllProperties=\"false\"><Properties><Property Name=\"Labels\" SelectAll=\"true\"><Query SelectAllProperties=\"false\"><Properties /></Query></Property></Properties></Query></Query></Actions><ObjectPaths><StaticMethod Id=\"7\" Name=\"GetTaxonomySession\" TypeId=\"{981cbc68-9edc-4f8d-872f-71146fcbb84f}\" /><Method Id=\"10\" ParentId=\"7\" Name=\"GetDefaultKeywordsTermStore\" /><Method Id=\"13\" ParentId=\"10\" Name=\"GetTerm\"><Parameters><Parameter Type=\"Guid\">${termId}</Parameter></Parameters></Method></ObjectPaths></Request>`;\n\n      const reqHeaders = new Headers();\n      reqHeaders.append(\"accept\", \"application/json\");\n      reqHeaders.append(\"content-type\", \"application/xml\");\n\n      const httpPostOptions: ISPHttpClientOptions = {\n        headers: reqHeaders,\n        body: data\n      };\n\n      const callResult = await this.context.spHttpClient.post(this.clientServiceUrl, SPHttpClient.configurations.v1, httpPostOptions);\n      const jsonResult = await callResult.json();\n\n      let node = jsonResult.find(x => x._ObjectType_ == \"SP.Taxonomy.Term\");\n      if (node && node.Labels && node.Labels._Child_Items_) {\n        result = node.Labels._Child_Items_.map(termLabel => termLabel.Value);\n      }\n    } catch (error) {\n      result = null;\n      console.log(error.message);\n    }\n    return result;\n  }\n\n  /**\n   * Gets the collection of term stores in the current SharePoint env\n   */\n  public getTermStores(): Promise<ITermStore[]> {\n    if (Environment.type === EnvironmentType.Local) {\n      // If the running environment is local, load the data from the mock\n      return this.getTermStoresFromMock();\n    } else {\n      // Retrieve the term store name, groups, and term sets\n      const data = '<Request AddExpandoFieldTypeSuffix=\"true\" SchemaVersion=\"15.0.0.0\" LibraryVersion=\"16.0.0.0\" ApplicationName=\".NET Library\" xmlns=\"http://schemas.microsoft.com/sharepoint/clientquery/2009\"><Actions><ObjectPath Id=\"2\" ObjectPathId=\"1\" /><ObjectIdentityQuery Id=\"3\" ObjectPathId=\"1\" /><ObjectPath Id=\"5\" ObjectPathId=\"4\" /><ObjectIdentityQuery Id=\"6\" ObjectPathId=\"4\" /><Query Id=\"7\" ObjectPathId=\"4\"><Query SelectAllProperties=\"false\"><Properties><Property Name=\"Id\" ScalarProperty=\"true\" /><Property Name=\"Name\" ScalarProperty=\"true\" /><Property Name=\"Groups\"><Query SelectAllProperties=\"false\"><Properties /></Query><ChildItemQuery SelectAllProperties=\"false\"><Properties><Property Name=\"Name\" ScalarProperty=\"true\" /><Property Name=\"Id\" ScalarProperty=\"true\" /><Property Name=\"IsSystemGroup\" ScalarProperty=\"true\" /><Property Name=\"TermSets\"><Query SelectAllProperties=\"false\"><Properties /></Query><ChildItemQuery SelectAllProperties=\"false\"><Properties><Property Name=\"Name\" ScalarProperty=\"true\" /><Property Name=\"Id\" ScalarProperty=\"true\" /><Property Name=\"Description\" ScalarProperty=\"true\" /><Property Name=\"Names\" ScalarProperty=\"true\" /></Properties></ChildItemQuery></Property></Properties></ChildItemQuery></Property></Properties></Query></Query></Actions><ObjectPaths><StaticMethod Id=\"1\" Name=\"GetTaxonomySession\" TypeId=\"{981cbc68-9edc-4f8d-872f-71146fcbb84f}\" /><Method Id=\"4\" ParentId=\"1\" Name=\"GetDefaultSiteCollectionTermStore\" /></ObjectPaths></Request>';\n\n      const reqHeaders = new Headers();\n      reqHeaders.append(\"accept\", \"application/json\");\n      reqHeaders.append(\"content-type\", \"application/xml\");\n\n      const httpPostOptions: ISPHttpClientOptions = {\n        headers: reqHeaders,\n        body: data\n      };\n\n      return this.context.spHttpClient.post(this.clientServiceUrl, SPHttpClient.configurations.v1, httpPostOptions).then((serviceResponse: SPHttpClientResponse) => {\n        return serviceResponse.json().then((serviceJSONResponse: any) => {\n          // Construct results\n          let termStoreResult: ITermStore[] = serviceJSONResponse.filter((r: { [x: string]: string; }) => r['_ObjectType_'] === 'SP.Taxonomy.TermStore');\n          // Check if term store was retrieved\n          if (termStoreResult.length > 0) {\n            // Check if the termstore needs to be filtered or limited\n            if (this.props.termsetNameOrID) {\n              return termStoreResult.map(termstore => {\n                let termGroups = termstore.Groups._Child_Items_;\n\n                // Check if the groups have to be limited to a specific term set\n                if (this.props.termsetNameOrID) {\n                  const termsetNameOrId = this.props.termsetNameOrID;\n                  termGroups = termGroups.map((group: IGroup) => {\n                    group.TermSets._Child_Items_ = group.TermSets._Child_Items_.filter((termSet: ITermSet) => termSet.Name === termsetNameOrId || this.cleanGuid(termSet.Id).toLowerCase() === this.cleanGuid(termsetNameOrId).toLowerCase());\n                    return group;\n                  });\n                }\n\n                // Filter out all systen groups\n                termGroups = termGroups.filter(group => !group.IsSystemGroup);\n\n                // Filter out empty groups\n                termGroups = termGroups.filter((group: IGroup) => group.TermSets._Child_Items_.length > 0);\n\n                // Map the new groups\n                termstore.Groups._Child_Items_ = termGroups;\n                return termstore;\n              });\n            }\n\n            // Return the term store results\n            return termStoreResult;\n          }\n          return [];\n        });\n      });\n    }\n  }\n\n  /**\n   * Gets the current term set\n   */\n  public async getTermSet(): Promise<ITermSet> {\n    if (Environment.type === EnvironmentType.Local) {\n      const termSetInfo = await SPTermStoreMockHttpClient.getAllTerms();\n      return termSetInfo;\n    } else {\n      const termStore = await this.getTermStores();\n      return this.getTermSetId(termStore, this.props.termsetNameOrID);\n    }\n  }\n\n  /**\n   * Retrieve all terms for the given term set\n   * @param termset\n   */\n  public async getAllTerms(termset: string, hideDeprecatedTags?: boolean, hideTagsNotAvailableForTagging?: boolean): Promise<ITermSet> {\n    if (Environment.type === EnvironmentType.Local) {\n      // If the running environment is local, load the data from the mock\n      return this.getAllMockTerms();\n    } else {\n      let termsetId: string = termset;\n      // Check if the provided term set property is a GUID or string\n      if (!this.isGuid(termset)) {\n        // Fetch the term store information\n        const termStore = await this.getTermStores();\n        // Get the ID of the provided term set name\n        const crntTermSet = this.getTermSetId(termStore, termset);\n        if (crntTermSet) {\n          termsetId = this.cleanGuid(crntTermSet.Id);\n        } else {\n          return null;\n        }\n      }\n\n      let childTerms = this.getTermsById(termsetId);\n\n      if (childTerms) {\n        return childTerms;\n      }\n\n      // Request body to retrieve all terms for the given term set\n      const data = `<Request xmlns=\"http://schemas.microsoft.com/sharepoint/clientquery/2009\" SchemaVersion=\"15.0.0.0\" LibraryVersion=\"16.0.0.0\" ApplicationName=\"Javascript Library\"><Actions><ObjectPath Id=\"1\" ObjectPathId=\"0\" /><ObjectIdentityQuery Id=\"2\" ObjectPathId=\"0\" /><ObjectPath Id=\"4\" ObjectPathId=\"3\" /><ObjectIdentityQuery Id=\"5\" ObjectPathId=\"3\" /><ObjectPath Id=\"7\" ObjectPathId=\"6\" /><ObjectIdentityQuery Id=\"8\" ObjectPathId=\"6\" /><ObjectPath Id=\"10\" ObjectPathId=\"9\" /><Query Id=\"11\" ObjectPathId=\"6\"><Query SelectAllProperties=\"true\"><Properties /></Query></Query><Query Id=\"12\" ObjectPathId=\"9\"><Query SelectAllProperties=\"false\"><Properties /></Query><ChildItemQuery SelectAllProperties=\"false\"><Properties><Property Name=\"IsRoot\" SelectAll=\"true\" /><Property Name=\"Labels\" SelectAll=\"true\" /><Property Name=\"TermsCount\" SelectAll=\"true\" /><Property Name=\"CustomSortOrder\" SelectAll=\"true\" /><Property Name=\"Id\" SelectAll=\"true\" /><Property Name=\"Name\" SelectAll=\"true\" /><Property Name=\"PathOfTerm\" SelectAll=\"true\" /><Property Name=\"Parent\" SelectAll=\"true\" /><Property Name=\"LocalCustomProperties\" SelectAll=\"true\" /><Property Name=\"IsDeprecated\" ScalarProperty=\"true\" /><Property Name=\"IsAvailableForTagging\" ScalarProperty=\"true\" /></Properties></ChildItemQuery></Query></Actions><ObjectPaths><StaticMethod Id=\"0\" Name=\"GetTaxonomySession\" TypeId=\"{981cbc68-9edc-4f8d-872f-71146fcbb84f}\" /><Method Id=\"3\" ParentId=\"0\" Name=\"GetDefaultKeywordsTermStore\" /><Method Id=\"6\" ParentId=\"3\" Name=\"GetTermSet\"><Parameters><Parameter Type=\"Guid\">${termsetId}</Parameter></Parameters></Method><Method Id=\"9\" ParentId=\"6\" Name=\"GetAllTerms\" /></ObjectPaths></Request>`;\n\n\n      const reqHeaders = new Headers();\n      reqHeaders.append(\"accept\", \"application/json\");\n      reqHeaders.append(\"content-type\", \"application/xml\");\n\n      const httpPostOptions: ISPHttpClientOptions = {\n        headers: reqHeaders,\n        body: data\n      };\n\n      return this.context.spHttpClient.post(this.clientServiceUrl, SPHttpClient.configurations.v1, httpPostOptions).then((serviceResponse: SPHttpClientResponse) => {\n        return serviceResponse.json().then((serviceJSONResponse: any) => {\n          const termStoreResultTermSets: ITermSet[] = serviceJSONResponse.filter((r: { [x: string]: string; }) => r['_ObjectType_'] === 'SP.Taxonomy.TermSet');\n\n          if (termStoreResultTermSets.length > 0) {\n            var termStoreResultTermSet = termStoreResultTermSets[0];\n            termStoreResultTermSet.Terms = [];\n            // Retrieve the term collection results\n            const termStoreResultTerms: ITerms[] = serviceJSONResponse.filter((r: { [x: string]: string; }) => r['_ObjectType_'] === 'SP.Taxonomy.TermCollection');\n            if (termStoreResultTerms.length > 0) {\n              // Retrieve all terms\n              let terms = termStoreResultTerms[0]._Child_Items_;\n\n              if (hideDeprecatedTags === true) {\n                terms = terms.filter(d => d[\"IsDeprecated\"] === false);\n              }\n\n              if (hideTagsNotAvailableForTagging === true) {\n                terms = terms.filter(d => d[\"IsAvailableForTagging\"] === true);\n              }\n\n              // Clean the term ID and specify the path depth\n              terms = terms.map(term => {\n                if (term.IsRoot) {\n                  term.CustomSortOrderIndex = (termStoreResultTermSet.CustomSortOrder) ? termStoreResultTermSet.CustomSortOrder.split(\":\").indexOf(this.cleanGuid(term.Id)) : -1;\n                } else {\n                  term.CustomSortOrderIndex = (term[\"Parent\"].CustomSortOrder) ? term[\"Parent\"].CustomSortOrder.split(\":\").indexOf(this.cleanGuid(term.Id)) : -1;\n                }\n                term.Id = this.cleanGuid(term.Id);\n                term['PathDepth'] = term.PathOfTerm.split(';').length;\n                term.TermSet = { Id: this.cleanGuid(termStoreResultTermSet.Id), Name: termStoreResultTermSet.Name };\n                if (term[\"Parent\"]) {\n                  term.ParentId = this.cleanGuid(term[\"Parent\"].Id);\n                }\n                return term;\n              });\n              // Check if the term set was not empty\n              if (terms.length > 0) {\n                // Sort the terms by PathOfTerm and their depth\n                terms = this.sortTerms(terms);\n                termStoreResultTermSet.Terms = terms;\n              }\n            }\n\n            sessionStorage.setItem(termsetId, JSON.stringify(termStoreResultTermSet));\n            return termStoreResultTermSet;\n          }\n          return null;\n        });\n      });\n    }\n  }\n\n  /**\n   * Get the term set ID by its name\n   * @param termstore\n   * @param termset\n   */\n  private getTermSetId(termstore: ITermStore[], termsetName: string): ITermSet {\n    if (termstore && termstore.length > 0 && termsetName) {\n      // Get the first term store\n      const ts = termstore[0];\n      // Check if the term store contains groups\n      if (ts.Groups && ts.Groups._Child_Items_) {\n        for (const group of ts.Groups._Child_Items_) {\n          // Check if the group contains term sets\n          if (group.TermSets && group.TermSets._Child_Items_) {\n            for (const termSet of group.TermSets._Child_Items_) {\n              // Check if the term set is found\n              if (termSet.Name === termsetName) {\n                return termSet;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n\n  /**\n   * Retrieve all terms that starts with the searchText\n   * @param searchText\n   */\n  public searchTermsByName(searchText: string): Promise<IPickerTerm[]> {\n    if (Environment.type === EnvironmentType.Local) {\n      // If the running environment is local, load the data from the mock\n      return SPTermStoreMockHttpClient.searchTermsByName(searchText);\n    } else {\n      return this.searchTermsByTermSet(searchText);\n    }\n  }\n\n  private getTermsById(termId) {\n    var terms = sessionStorage.getItem(termId);\n    if (terms)\n      return JSON.parse(terms);\n    else\n      return null;\n  }\n\n  private searchTermsBySearchText(terms, searchText) {\n    if (terms) {\n      return terms.filter((t) => { return t.name.toLowerCase().indexOf(searchText.toLowerCase()) > -1; });\n    }\n    else\n      return [];\n  }\n\n  public async searchTermsByTermId(searchText: string, termId: string): Promise<IPickerTerm[]> {\n    if (Environment.type === EnvironmentType.Local) {\n      // If the running environment is local, load the data from the mock\n      return SPTermStoreMockHttpClient.searchTermsByName(searchText);\n    } else {\n      var childTerms = this.getTermsById(termId);\n      if (childTerms) {\n        return this.searchTermsBySearchText(childTerms, searchText);\n      }\n      else {\n        const {\n          termsetNameOrID,\n          hideDeprecatedTags,\n          hideTagsNotAvailableForTagging\n        } = this.props;\n\n        const terms = await this.getAllTermsByAnchorId(\n          termsetNameOrID,\n          termId,\n          hideDeprecatedTags,\n          hideTagsNotAvailableForTagging);\n\n        if (terms) {\n          return this.searchTermsBySearchText(terms, searchText);\n        }\n      }\n\n      return null;\n    }\n  }\n\n  /**\n   * Retrieve all terms for the given term set and anchorId\n   */\n  public async getAllTermsByAnchorId(termsetNameOrID: string, anchorId: string, hideDeprecatedTags?: boolean, hideTagsNotAvailableForTagging?: boolean): Promise<IPickerTerm[]> {\n\n    let returnTerms: IPickerTerm[] = [];\n\n    if (Environment.type === EnvironmentType.Local) {\n      // If the running environment is local, load the data from the mock\n      let terms = await this.getAllMockTermsByAnchor();\n      terms.forEach(term => {\n        returnTerms.push(this.convertTermToPickerTerm(term));\n      });\n    } else {\n      const childTerms = this.getTermsById(anchorId);\n      if (childTerms) {\n        return childTerms;\n      }\n\n      let termSet = await this.getAllTerms(termsetNameOrID, hideDeprecatedTags, hideTagsNotAvailableForTagging);\n      let terms = termSet.Terms;\n      if (anchorId) {\n        const anchorTerm = terms.filter(t => t.Id.toLowerCase() === anchorId.toLowerCase()).shift();\n        if (anchorTerm) {\n          // Append ';' separator, as a suffix to anchor term path.\n          const anchorTermPath = `${anchorTerm.PathOfTerm};`;\n          const anchorTerms: ITerm[] = terms.filter(t => t.PathOfTerm.substring(0, anchorTermPath.length) === anchorTermPath && t.Id !== anchorTerm.Id);\n\n          anchorTerms.forEach(term => {\n            returnTerms.push(this.convertTermToPickerTerm(term));\n          });\n\n          sessionStorage.setItem(anchorId, JSON.stringify(returnTerms));\n        }\n      } else {\n        terms.forEach(term => {\n          returnTerms.push(this.convertTermToPickerTerm(term));\n        });\n      }\n    }\n\n    return returnTerms;\n  }\n\n  /**\n     * Searches terms for the given term set\n     * @param searchText\n     * @param termsetId\n     */\n  private searchTermsByTermSet(searchText: string): Promise<IPickerTerm[]> {\n    if (Environment.type === EnvironmentType.Local) {\n      // If the running environment is local, load the data from the mock\n      return SPTermStoreMockHttpClient.searchTermsByName(searchText);\n    } else {\n      return new Promise<IPickerTerm[]>(resolve => {\n        this.getTermStores().then(termStore => {\n          let TermSetId = this.props.termsetNameOrID;\n          if (!this.isGuid(TermSetId)) {\n            // Get the ID of the provided term set name\n            const crntTermSet = this.getTermSetId(termStore, TermSetId);\n            if (crntTermSet) {\n              TermSetId = this.cleanGuid(crntTermSet.Id);\n            } else {\n              resolve(null);\n              return;\n            }\n          }\n          if (termStore === undefined || termStore.length  === 0) {\n            resolve(null);\n            return;\n          }\n\n          let data = {\n            start: searchText,\n            lcid : this.context.pageContext.web.language, // TODO : get the user's navitation LCID. Here it's the default web language LCID\n            sspList: this.cleanGuid(termStore[0].Id),\n            termSetList: TermSetId,\n            anchorId: this.props.anchorId ? this.props.anchorId : EmptyGuid,\n            isSpanTermStores: false,\n            isSpanTermSets: false,\n            isIncludeUnavailable: this.props.hideTagsNotAvailableForTagging === true,\n            isIncludeDeprecated: this.props.hideDeprecatedTags === true,\n            isAddTerms: false,\n            isIncludePathData: false,\n            excludeKeyword: false,\n            excludedTermset: EmptyGuid\n          };\n\n          const reqHeaders = new Headers();\n          reqHeaders.append(\"accept\", \"application/json\");\n          reqHeaders.append(\"content-type\", \"application/json\");\n\n          const httpPostOptions: ISPHttpClientOptions = {\n            headers: reqHeaders,\n            body: JSON.stringify(data)\n          };\n\n\n          return this.context.spHttpClient.post(this.suggestionServiceUrl, SPHttpClient.configurations.v1, httpPostOptions).then((serviceResponse: SPHttpClientResponse) => {\n            return serviceResponse.json().then((serviceJSONResponse: any) => {\n              const groups = serviceJSONResponse.d.Groups;\n              if (groups && groups.length > 0) {\n                // Retrieve the term collection results\n                const terms: ISuggestTerm[] = groups[0].Suggestions;\n                if (terms.length > 0) {\n                  // Retrieve all terms\n\n                  let returnTerms: IPickerTerm[] = terms.map((term: ISuggestTerm) => this.convertSuggestTermToPickerTerm(term));\n                  resolve(returnTerms);\n                  return;\n                }\n\n              }\n\n              resolve([]);\n            });\n          });\n        });\n      });\n    }\n  }\n\n  private isGuid(strGuid: string): boolean {\n    return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(strGuid);\n  }\n\n  /**\n   * Sorting terms based on their path and depth\n   *\n   * @param terms\n   */\n  private sortTerms(terms: ITerm[]) {\n    // Start sorting by depth\n    let newTermsOrder: ITerm[] = [];\n    let itemsToSort = true;\n    let pathLevel = 1;\n    while (itemsToSort) {\n      // Get terms for the current level\n      let crntTerms = terms.filter(term => term.PathDepth === pathLevel);\n      if (crntTerms && crntTerms.length > 0) {\n        crntTerms = crntTerms.sort(this.sortTermByPath);\n\n        if (pathLevel !== 1) {\n          crntTerms = crntTerms.reverse();\n          for (const crntTerm of crntTerms) {\n            const pathElms = crntTerm.PathOfTerm.split(\";\");\n            // Last item is not needed for parent path\n            pathElms.pop();\n            // Find the parent item and add the new item\n            const idx = findIndex(newTermsOrder, term => term.PathOfTerm === pathElms.join(\";\"));\n            if (idx !== -1) {\n              newTermsOrder.splice(idx + 1, 0, crntTerm);\n            } else {\n              // Push the item at the end if the parent couldn't be found\n              newTermsOrder.push(crntTerm);\n            }\n          }\n        } else {\n          newTermsOrder = crntTerms;\n        }\n\n        ++pathLevel;\n      } else {\n        itemsToSort = false;\n      }\n    }\n    return newTermsOrder;\n  }\n\n  /**\n   * Sort the terms by their path\n   *\n   * @param a term 2\n   * @param b term 2\n   */\n  private sortTermByPath(a: ITerm, b: ITerm) {\n    if (a.CustomSortOrderIndex === -1) {\n      if (a.PathOfTerm.toLowerCase() < b.PathOfTerm.toLowerCase()) {\n        return -1;\n      }\n      if (a.PathOfTerm.toLowerCase() > b.PathOfTerm.toLowerCase()) {\n        return 1;\n      }\n      return 0;\n    } else {\n      if (a.CustomSortOrderIndex < b.CustomSortOrderIndex) {\n        return -1;\n      }\n      if (a.CustomSortOrderIndex > b.CustomSortOrderIndex) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Clean the Guid from the Web Service response\n   * @param guid\n   */\n  public cleanGuid(guid: string): string {\n    if (guid !== undefined) {\n      return guid.replace('/Guid(', '').replace('/', '').replace(')', '');\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * Returns 3 fake SharePoint lists for the Mock mode\n   */\n  private getTermStoresFromMock(): Promise<ITermStore[]> {\n    return SPTermStoreMockHttpClient.getTermStores(this.context.pageContext.web.absoluteUrl).then((data) => {\n      return data;\n    }) as Promise<ITermStore[]>;\n  }\n\n  /**\n   * Returns 3 fake SharePoint lists for the Mock mode\n   */\n  private getAllMockTerms(): Promise<ITermSet> {\n    return SPTermStoreMockHttpClient.getAllTerms().then((data) => {\n      return data;\n    }) as Promise<ITermSet>;\n  }\n\n  /**\n   * Returns 3 fake SharePoint lists for the Mock mode\n   */\n  private getAllMockTermsByAnchor(): Promise<ITerm[]> {\n    return SPTermStoreMockHttpClient.getAllTermsByAnchorId().then((data) => {\n      return data;\n    }) as Promise<ITerm[]>;\n  }\n\n  private convertTermToPickerTerm(term: ITerm): IPickerTerm {\n    return {\n      key: this.cleanGuid(term.Id),\n      name: term.Name,\n      path: term.PathOfTerm,\n      termSet: this.cleanGuid(term.TermSet.Id),\n      termSetName: term.TermSet.Name\n    };\n  }\n\n  private convertSuggestTermToPickerTerm(term: ISuggestTerm): IPickerTerm {\n    let path: string = \"\";\n    let termSetName: string = \"\";\n    if (term.Paths && term.Paths.length > 0) {\n      const fullPath = term.Paths[0].replace(/^\\[/, \"\").replace(/\\]$/, \"\");\n      const fullPathParts = fullPath.split(\":\");\n      path = fullPathParts.join(\";\") + \";\" +  term.DefaultLabel;\n      termSetName = fullPathParts[0];\n    }\n    return {\n      key: this.cleanGuid(term.Id),\n      name: term.DefaultLabel,\n      path: path,\n      termSet: EmptyGuid, // TermSet Guid is not given with suggestion\n      termSetName: termSetName\n    };\n  }\n}\n"],"sourceRoot":"../../src"}