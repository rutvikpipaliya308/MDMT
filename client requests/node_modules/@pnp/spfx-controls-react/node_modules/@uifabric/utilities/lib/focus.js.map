{"version":3,"file":"focus.js","sourceRoot":"../src/","sources":["focus.ts"],"names":[],"mappings":"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","sourcesContent":["/* tslint:disable:no-string-literal */\n\nimport {\n  elementContainsAttribute,\n  elementContains,\n  getDocument,\n  getWindow\n} from './dom';\n\nconst IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nconst IS_VISIBLE_ATTRIBUTE = 'data-is-visible';\nconst FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nconst FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';\n\n/**\n * Gets the first focusable element.\n *\n * @public\n */\nexport function getFirstFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean): HTMLElement | null {\n\n  return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);\n}\n\n/**\n * Gets the last focusable element.\n *\n * @public\n */\nexport function getLastFocusable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean): HTMLElement | null {\n\n  return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);\n}\n\n/**\n * Gets the last tabbable element.\n *\n * @public\n */\nexport function getLastTabbable(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement,\n  includeElementsInFocusZones?: boolean): HTMLElement | null {\n\n  return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones, false, true);\n}\n\n/**\n * Attempts to focus the first focusable element that is a child or child's child of the rootElement.\n *\n * @public\n * @param rootElement - Element to start the search for a focusable child.\n * @returns True if focus was set, false if it was not.\n */\nexport function focusFirstChild(\n  rootElement: HTMLElement): boolean {\n  let element: HTMLElement | null = getNextElement(rootElement, rootElement, true, false, false, true);\n\n  if (element) {\n    focusAsync(element);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Traverse to find the previous element.\n *\n * @public\n */\nexport function getPreviousElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  traverseChildren?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean,\n  tabbable?: boolean): HTMLElement | null {\n\n  if (!currentElement ||\n    (!allowFocusRoot && currentElement === rootElement)) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check its children.\n  if (traverseChildren && isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    const childMatch = getPreviousElement(\n      rootElement,\n      currentElement.lastElementChild as HTMLElement,\n      true,\n      true,\n      true,\n      includeElementsInFocusZones,\n      allowFocusRoot,\n      tabbable);\n\n    if (childMatch) {\n      if ((tabbable && (isElementTabbable(childMatch, true))) || !tabbable) {\n        return childMatch;\n      }\n\n      const childMatchSiblingMatch = getPreviousElement(\n        rootElement,\n        childMatch.previousElementSibling as HTMLElement,\n        true,\n        true,\n        true,\n        includeElementsInFocusZones,\n        allowFocusRoot,\n        tabbable\n      );\n      if (childMatchSiblingMatch) {\n        return childMatchSiblingMatch;\n      }\n\n      let childMatchParent = childMatch.parentElement;\n\n      // At this point if we have not found any potential matches\n      // start looking at the rest of the subtree under the currentParent.\n      // NOTE: We do not want to recurse here because doing so could\n      // cause elements to get skipped.\n      while (childMatchParent && childMatchParent !== currentElement) {\n        const childMatchParentMatch = getPreviousElement(\n          rootElement,\n          childMatchParent.previousElementSibling as HTMLElement,\n          true,\n          true,\n          true,\n          includeElementsInFocusZones,\n          allowFocusRoot,\n          tabbable\n        );\n\n        if (childMatchParentMatch) {\n          return childMatchParentMatch;\n        }\n\n        childMatchParent = childMatchParent.parentElement;\n      }\n    }\n  }\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {\n    return currentElement;\n  }\n\n  // Check its previous sibling.\n  const siblingMatch = getPreviousElement(\n    rootElement,\n    currentElement.previousElementSibling as HTMLElement,\n    true,\n    true,\n    true,\n    includeElementsInFocusZones,\n    allowFocusRoot,\n    tabbable);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  // Check its parent.\n  if (!suppressParentTraversal) {\n    return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones,\n      allowFocusRoot, tabbable);\n  }\n\n  return null;\n}\n\n/**\n * Traverse to find the next focusable element.\n *\n * @public\n */\nexport function getNextElement(\n  rootElement: HTMLElement,\n  currentElement: HTMLElement | null,\n  checkNode?: boolean,\n  suppressParentTraversal?: boolean,\n  suppressChildTraversal?: boolean,\n  includeElementsInFocusZones?: boolean,\n  allowFocusRoot?: boolean): HTMLElement | null {\n\n  if (\n    !currentElement ||\n    (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {\n    return null;\n  }\n\n  let isCurrentElementVisible = isElementVisible(currentElement);\n\n  // Check the current node, if it's not the first traversal.\n  if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {\n    return currentElement;\n  }\n\n  // Check its children.\n  if (!suppressChildTraversal && isCurrentElementVisible &&\n    (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {\n    const childMatch = getNextElement(\n      rootElement,\n      currentElement.firstElementChild as HTMLElement,\n      true,\n      true,\n      false,\n      includeElementsInFocusZones,\n      allowFocusRoot);\n\n    if (childMatch) {\n      return childMatch;\n    }\n  }\n\n  if (currentElement === rootElement) {\n    return null;\n  }\n\n  // Check its sibling.\n  const siblingMatch = getNextElement(\n    rootElement,\n    currentElement.nextElementSibling as HTMLElement,\n    true,\n    true,\n    false,\n    includeElementsInFocusZones,\n    allowFocusRoot);\n\n  if (siblingMatch) {\n    return siblingMatch;\n  }\n\n  if (!suppressParentTraversal) {\n    return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones,\n      allowFocusRoot);\n  }\n\n  return null;\n}\n\n/**\n * Determines if an element is visible.\n *\n * @public\n */\nexport function isElementVisible(element: HTMLElement | undefined | null): boolean {\n  // If the element is not valid, return false.\n  if (!element || !element.getAttribute) {\n    return false;\n  }\n\n  const visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);\n\n  // If the element is explicitly marked with the visibility attribute, return that value as boolean.\n  if (visibilityAttribute !== null && visibilityAttribute !== undefined) {\n    return visibilityAttribute === 'true';\n  }\n\n  // Fallback to other methods of determining actual visibility.\n  return (element.offsetHeight !== 0 ||\n    element.offsetParent !== null ||\n    // tslint:disable-next-line:no-any\n    (element as any).isVisible === true); // used as a workaround for testing.\n}\n\n/**\n * Determines if an element can receive focus.\n *\n * @public\n */\nexport function isElementTabbable(element: HTMLElement, checkTabIndex?: boolean): boolean {\n\n  // If this element is null or is disabled, it is not considered tabbable.\n  if (!element || (element as HTMLButtonElement).disabled) {\n    return false;\n  }\n\n  let tabIndex = 0;\n  let tabIndexAttributeValue = null;\n\n  if (element && element.getAttribute) {\n    tabIndexAttributeValue = element.getAttribute('tabIndex');\n\n    if (tabIndexAttributeValue) {\n      tabIndex = parseInt(tabIndexAttributeValue, 10);\n    }\n  }\n\n  let isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;\n  let isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;\n\n  const result = !!element &&\n    isFocusableAttribute !== 'false' &&\n    (element.tagName === 'A' ||\n      (element.tagName === 'BUTTON') ||\n      (element.tagName === 'INPUT') ||\n      (element.tagName === 'TEXTAREA') ||\n      isFocusableAttribute === 'true' ||\n      isTabIndexSet ||\n      element.getAttribute && element.getAttribute('role') === 'button'\n    );\n\n  return checkTabIndex ? (tabIndex !== -1) && result : result;\n}\n\n/**\n * Determines if a given element is a focus zone.\n *\n * @public\n */\nexport function isElementFocusZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));\n}\n\n/**\n * Determines if a given element is a focus sub zone.\n *\n * @public\n */\nexport function isElementFocusSubZone(element?: HTMLElement): boolean {\n  return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');\n}\n\n/**\n * Determines if an element, or any of its children, contain focus.\n *\n * @public\n */\nexport function doesElementContainFocus(element: HTMLElement): boolean {\n  let document = getDocument(element);\n  let currentActiveElement: HTMLElement | undefined = document && document.activeElement as HTMLElement;\n  if (currentActiveElement && elementContains(element, currentActiveElement)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines if an, or any of its ancestors, sepcificies that it doesn't want focus to wrap\n * @param element - element to start searching from\n * @param noWrapDataAttribute - the no wrap data attribute to match (either)\n * @returns true if focus should wrap, false otherwise\n */\nexport function shouldWrapFocus(element: HTMLElement, noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap'): boolean {\n\n  return elementContainsAttribute(element, noWrapDataAttribute) === 'true' ? false : true;\n}\n\nlet targetToFocusOnNextRepaint: HTMLElement | { focus: () => void } | null | undefined = undefined;\n\n/**\n * Sets focus to an element asynchronously. The focus will be set at the next browser repaint,\n * meaning it won't cause any extra recalculations. If more than one focusAsync is called during one frame,\n * only the latest called focusAsync element will actually be focused\n * @param element The element to focus\n */\nexport function focusAsync(element: HTMLElement | { focus: () => void } | undefined | null): void {\n  if (element) {\n    // An element was already queued to be focused, so replace that one with the new element\n    if (targetToFocusOnNextRepaint) {\n      targetToFocusOnNextRepaint = element;\n      return;\n    }\n\n    targetToFocusOnNextRepaint = element;\n\n    const win = getWindow(element as Element);\n\n    if (win) {\n      // element.focus() is a no-op if the element is no longer in the DOM, meaning this is always safe\n      win.requestAnimationFrame(() => {\n        targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus();\n\n        // We are done focusing for this frame, so reset the queued focus element\n        targetToFocusOnNextRepaint = undefined;\n      });\n    }\n  }\n}\n"]}