{"version":3,"file":"GlobalSettings.js","sourceRoot":"../src/","sources":["GlobalSettings.ts"],"names":[],"mappings":"AAAA;;;;;;;GAOG;;;;IAEH,IAAM,yBAAyB,GAAG,oBAAoB,CAAC;IACvD,IAAM,wBAAwB,GAAG,eAAe,CAAC;IAEjD,kCAAkC;IAClC,IAAI,eAAe,GAA2B,EAAE,CAAC;IACjD,IAAI,QAAQ,GAAG,CAAC,CAAC;IAEjB,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;QACjC,kCAAkC;QAClC,IAAI,GAAG,GAAG,MAAa,CAAC;QAExB,eAAe,GAAG,GAAG,CAAC,yBAAyB,CAAC,GAAG,GAAG,CAAC,yBAAyB,CAAC;YAC/E,GAAC,wBAAwB,IAAG,EAAE;eAC/B,CAAC;KACH;IAED,IAAM,UAAU,GAAG,eAAe,CAAC,wBAAwB,CAAC,CAAC;IAyB7D;;;;;;OAMG;IACH;QAAA;QA+CA,CAAC;QA9Ce,uBAAQ,GAAtB,UAA0B,GAAW,EAAE,YAA4B;YACjE,IAAI,eAAe,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE;gBACtC,eAAe,CAAC,GAAG,CAAC,GAAG,OAAO,YAAY,KAAK,UAAU,CAAC,CAAC,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC;aAC3F;YAED,OAAO,eAAe,CAAC,GAAG,CAAC,CAAC;QAC9B,CAAC;QAEa,uBAAQ,GAAtB,UAA0B,GAAW,EAAE,KAAQ;YAC7C,IAAI,QAAQ,GAAG,eAAe,CAAC,GAAG,CAAC,CAAC;YAEpC,IAAI,KAAK,KAAK,QAAQ,EAAE;gBACtB,eAAe,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;gBAE7B,IAAI,iBAAiB,GAAG;oBACtB,QAAQ,UAAA;oBACR,KAAK,OAAA;oBACL,GAAG,KAAA;iBACJ,CAAC;gBAEF,KAAK,IAAI,EAAE,IAAI,UAAU,EAAE;oBACzB,IAAI,UAAU,CAAC,cAAc,CAAC,EAAE,CAAC,EAAE;wBACjC,UAAU,CAAC,EAAE,CAAC,CAAC,iBAAiB,CAAC,CAAC;qBACnC;iBACF;aACF;YAED,OAAO,KAAK,CAAC;QACf,CAAC;QAEa,gCAAiB,GAA/B,UAAgC,EAAwB;YACtD,yGAAyG;YACzG,kGAAkG;YAClG,IAAI,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC;YAEnB,IAAI,CAAC,EAAE,EAAE;gBACP,EAAE,GAAG,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC;aACrC;YAED,UAAU,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC;QACtB,CAAC;QAEa,mCAAoB,GAAlC,UAAmC,EAAwB;YACzD,OAAO,UAAU,CAAC,EAAE,CAAC,MAAgB,CAAC,CAAC;QACzC,CAAC;QAEH,qBAAC;IAAD,CAAC,AA/CD,IA+CC;IA/CY,wCAAc","sourcesContent":["/**\n * Storing global state in local module variables has issues when more than one copy\n * if the module gets loaded on the page (due to a bundling error or simply by consuming\n * a prebundled script.)\n *\n * This file contains helpers to deal with the getting and setting local state, and allows\n * callers to get called back when it mutates.\n */\n\nconst GLOBAL_SETTINGS_PROP_NAME = '__globalSettings__';\nconst CALLBACK_STATE_PROP_NAME = '__callbacks__';\n\n// tslint:disable-next-line:no-any\nlet _globalSettings: { [key: string]: any } = {};\nlet _counter = 0;\n\nif (typeof window !== 'undefined') {\n  // tslint:disable-next-line:no-any\n  let win = window as any;\n\n  _globalSettings = win[GLOBAL_SETTINGS_PROP_NAME] = win[GLOBAL_SETTINGS_PROP_NAME] || {\n    [CALLBACK_STATE_PROP_NAME]: {}\n  };\n}\n\nconst _callbacks = _globalSettings[CALLBACK_STATE_PROP_NAME];\n\n/**\n * Change description used for change callbacks in GlobalSettings.\n *\n * @public\n */\nexport interface IChangeDescription {\n  key: string;\n  // tslint:disable-next-line:no-any\n  oldValue: any;\n  // tslint:disable-next-line:no-any\n  value: any;\n}\n\n/**\n * Change event callback.\n *\n * @public\n */\nexport interface IChangeEventCallback {\n  __id__?: string;\n  (changeDescription?: IChangeDescription): void;\n}\n\n/**\n * Global settings helper, which stores settings in the global (window) namespace.\n * If window is not provided, it will store settings in module scope. Provides a\n * way to observe changes as well when their values change.\n *\n * @public\n */\nexport class GlobalSettings {\n  public static getValue<T>(key: string, defaultValue?: T | (() => T)): T {\n    if (_globalSettings[key] === undefined) {\n      _globalSettings[key] = typeof defaultValue === 'function' ? defaultValue() : defaultValue;\n    }\n\n    return _globalSettings[key];\n  }\n\n  public static setValue<T>(key: string, value: T): T {\n    let oldValue = _globalSettings[key];\n\n    if (value !== oldValue) {\n      _globalSettings[key] = value;\n\n      let changeDescription = {\n        oldValue,\n        value,\n        key\n      };\n\n      for (let id in _callbacks) {\n        if (_callbacks.hasOwnProperty(id)) {\n          _callbacks[id](changeDescription);\n        }\n      }\n    }\n\n    return value;\n  }\n\n  public static addChangeListener(cb: IChangeEventCallback): void {\n    // Note: we use generated ids on the callbacks to create a map of the callbacks, which optimizes removal.\n    // (It's faster to delete a key than it is to look up the index of an object and splice an array.)\n    let id = cb.__id__;\n\n    if (!id) {\n      id = cb.__id__ = String(_counter++);\n    }\n\n    _callbacks[id] = cb;\n  }\n\n  public static removeChangeListener(cb: IChangeEventCallback): void {\n    delete _callbacks[cb.__id__ as string];\n  }\n\n}\n"]}