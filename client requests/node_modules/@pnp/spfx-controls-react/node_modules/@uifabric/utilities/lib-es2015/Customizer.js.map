{"version":3,"file":"Customizer.js","sourceRoot":"../src/","sources":["Customizer.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,KAAK,SAAS,MAAM,YAAY,CAAC;AACxC,OAAO,EAAE,aAAa,EAAc,MAAM,iBAAiB,CAAC;AAmD5D;;;;;;;;;;;;GAYG;AACH;IAAgC,sCAAmD;IAWjF,kCAAkC;IAClC,oBAAY,KAAuB,EAAE,OAAY;QAAjD,YACE,kBAAM,KAAK,CAAC,SAGb;QADC,KAAI,CAAC,KAAK,GAAG,KAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;;IACvD,CAAC;IAEM,oCAAe,GAAtB;QACE,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,kCAAkC;IAC3B,8CAAyB,GAAhC,UAAiC,QAAa,EAAE,UAAe;QAC7D,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC,CAAC;IAC/D,CAAC;IAEM,2BAAM,GAAb;QACE,OAAO,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;IAClD,CAAC;IAEO,uCAAkB,GAA1B,UACE,KAAuB,EACvB,OAA2B;QAGzB,IAAA,2BAAqD,EAArD,0EAAqD,CAC3C;QAEZ,OAAO;YACL,cAAc,EAAE;gBACd,QAAQ,EAAE,aAAa,CAAC,cAAc,CAAC,QAAQ,EAAE,KAAK,CAAC,QAAQ,CAAC;gBAChE,cAAc,EAAE,mBAAmB,CAAC,cAAc,CAAC,cAAc,EAAE,KAAK,CAAC,cAAc,CAAC;aACzF;SACF,CAAC;IACJ,CAAC;IA5Ca,uBAAY,GAEtB;QACA,cAAc,EAAE,SAAS,CAAC,MAAM;KACjC,CAAC;IAEU,4BAAiB,GAE3B,UAAU,CAAC,YAAY,CAAC;IAqC9B,iBAAC;CAAA,AA9CD,CAAgC,aAAa,GA8C5C;SA9CY,UAAU;AAgDvB,uBAAuB,WAA0B,EAAE,WAAyC;IAArE,4BAAA,EAAA,gBAA0B;IAC/C,IAAM,iBAAiB,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;IAEzG,OAAO,iBAAiB,CAAC,WAAW,CAAC,CAAC;AACxC,CAAC;AAED,6BAA6B,WAA0B,EAAE,WAAyC;IAArE,4BAAA,EAAA,gBAA0B;IACrD,IAAM,iBAAiB,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,uBAAuB,CAAC,WAAW,CAAC,CAAC;IAE/G,OAAO,iBAAiB,CAAC,WAAW,CAAC,CAAC;AACxC,CAAC;AAED,4BAA4B,QAAsC;IAChE,OAAO,OAAO,QAAQ,KAAK,UAAU,CAAC;AACxC,CAAC;AAED,2BAA2B,WAAoB;IAC7C,OAAO,UAAC,QAAkB,IAAK,OAAA,WAAW,CAAC,CAAC,sBAAM,WAAW,EAAK,QAAQ,EAAG,CAAC,CAAC,QAAQ,EAAxD,CAAwD,CAAC;AAC1F,CAAC;AAED,iCAAiC,uBAAsC;IAAtC,wCAAA,EAAA,4BAAsC;IACrE,OAAO,UAAC,iBAA2B;QACjC,IAAM,iBAAiB,wBAAkB,iBAAiB,CAAE,CAAC;QAE7D,KAAK,IAAI,SAAS,IAAI,uBAAuB,EAAE;YAC7C,IAAI,uBAAuB,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;gBACrD,iBAAiB,CAAC,SAAS,CAAC,wBAAQ,iBAAiB,CAAC,SAAS,CAAC,EAAK,uBAAuB,CAAC,SAAS,CAAC,CAAE,CAAC;aAC3G;SACF;QAED,OAAO,iBAAiB,CAAC;IAC3B,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { BaseComponent, IBaseProps } from './BaseComponent';\nimport { ICustomizations, Settings, SettingsFunction } from './Customizations';\n\nexport interface ICustomizerContext {\n  customizations: ICustomizations;\n}\n\nexport type ICustomizerProps = IBaseProps & Partial<{\n  /**\n   * @description\n   * Settings are used as general settings for the React tree below.\n   * Components can subscribe to receive the settings by using `customizable`.\n   *\n   * @example\n   * Settings can be represented by a plain object that contains the key value pairs.\n   * ```\n   *  <Customizer settings={{ color: 'red' }} />\n   * ```\n   * or a function that receives the current settings and returns the new ones\n   * ```\n   *  <Customizer settings={(currentSettings) => ({ ...currentSettings, color: 'red' })} />\n   * ```\n   */\n  settings: Settings | SettingsFunction;\n  /**\n   * @description\n   * Scoped settings are settings that are scoped to a specific scope. The\n   * scope is the name that is passed to the `customizable` function when the\n   * the component is customized.\n   *\n   * @example\n   * Scoped settings can be represented by a plain object that contains the key value pairs.\n   * ```\n   *  const myScopedSettings = {\n   *    Button: { color: 'red' };\n   *  };\n   *\n   *  <Customizer scopedSettings={myScopedSettings} />\n   * ```\n   * or a function that receives the current settings and returns the new ones\n   * ```\n   *  const myScopedSettings = {\n   *    Button: { color: 'red' };\n   *  };\n   *\n   *  <Customizer scopedSettings={(currentScopedSettings) => ({ ...currentScopedSettings, ...myScopedSettings })} />\n   * ```\n   */\n  scopedSettings: Settings | SettingsFunction\n}>;\n\n/**\n * The Customizer component allows for default props to be mixed into components which\n * are decorated with the customizable() decorator. This enables injection scenarios like:\n *\n * 1. render svg icons instead of the icon font within all buttons\n * 2. inject a custom theme object into a component\n *\n * Props are provided via the settings prop which should be one of the following:\n * - A json map which contains 1 or more name/value pairs representing injectable props.\n * - A function that receives the current settings and returns the new ones that apply to the scope\n *\n * @public\n */\nexport class Customizer extends BaseComponent<ICustomizerProps, ICustomizerContext> {\n  public static contextTypes: {\n    customizations: PropTypes.Requireable<{}>;\n  } = {\n      customizations: PropTypes.object\n    };\n\n  public static childContextTypes: {\n    customizations: PropTypes.Requireable<{}>;\n  } = Customizer.contextTypes;\n\n  // tslint:disable-next-line:no-any\n  constructor(props: ICustomizerProps, context: any) {\n    super(props);\n\n    this.state = this._getCustomizations(props, context);\n  }\n\n  public getChildContext(): ICustomizerContext {\n    return this.state;\n  }\n\n  // tslint:disable-next-line:no-any\n  public componentWillReceiveProps(newProps: any, newContext: any): void {\n    this.setState(this._getCustomizations(newProps, newContext));\n  }\n\n  public render(): React.ReactElement<{}> {\n    return React.Children.only(this.props.children);\n  }\n\n  private _getCustomizations(\n    props: ICustomizerProps,\n    context: ICustomizerContext\n  ): ICustomizerContext {\n    const {\n      customizations = { settings: {}, scopedSettings: {} }\n    } = context;\n\n    return {\n      customizations: {\n        settings: mergeSettings(customizations.settings, props.settings),\n        scopedSettings: mergeScopedSettings(customizations.scopedSettings, props.scopedSettings),\n      }\n    };\n  }\n}\n\nfunction mergeSettings(oldSettings: Settings = {}, newSettings?: Settings | SettingsFunction): Settings {\n  const mergeSettingsWith = isSettingsFunction(newSettings) ? newSettings : settingsMergeWith(newSettings);\n\n  return mergeSettingsWith(oldSettings);\n}\n\nfunction mergeScopedSettings(oldSettings: Settings = {}, newSettings?: Settings | SettingsFunction): Settings {\n  const mergeSettingsWith = isSettingsFunction(newSettings) ? newSettings : scopedSettingsMergeWith(newSettings);\n\n  return mergeSettingsWith(oldSettings);\n}\n\nfunction isSettingsFunction(settings?: Settings | SettingsFunction): settings is SettingsFunction {\n  return typeof settings === 'function';\n}\n\nfunction settingsMergeWith(newSettings?: object): (settings: Settings) => Settings {\n  return (settings: Settings) => newSettings ? { ...newSettings, ...settings } : settings;\n}\n\nfunction scopedSettingsMergeWith(scopedSettingsFromProps: Settings = {}): (scopedSettings: Settings) => Settings {\n  return (oldScopedSettings: Settings): Settings => {\n    const newScopedSettings: Settings = { ...oldScopedSettings };\n\n    for (let scopeName in scopedSettingsFromProps) {\n      if (scopedSettingsFromProps.hasOwnProperty(scopeName)) {\n        newScopedSettings[scopeName] = { ...oldScopedSettings[scopeName], ...scopedSettingsFromProps[scopeName] };\n      }\n    }\n\n    return newScopedSettings;\n  };\n}"]}