{"version":3,"sources":["../../../../packages/logging/src/logger.ts","../../../../packages/logging/src/listeners.ts"],"names":["Logger","Object","defineProperty","instance","activeLogLevel","value","_instance","LoggerImpl","subscribe","listeners","_i","arguments","length","map","listener","clearSubscribers","count","write","message","level","log","writeJSON","json","JSON","stringify","entry","error","err","data","subscribers","this","prototype","push","s","slice","subscriber","ConsoleListener","msg","format","console","warn","join","FunctionListener","method"],"mappings":"gNAQA,IAAAA,EAAA,WAAA,SAAAA,KAkFA,OA3EIC,OAAAC,eAAkBF,EAAA,sBAAlB,WACI,OAAOA,EAAOG,SAASC,oBAG3B,SAAiCC,GAC7BL,EAAOG,SAASC,eAAiBC,mCAGrCJ,OAAAC,eAAmBF,EAAA,gBAAnB,WAII,YAHgC,IAArBA,EAAOM,WAAkD,OAArBN,EAAOM,YAClDN,EAAOM,UAAY,IAAIC,GAEpBP,EAAOM,2CAQJN,EAAAQ,UAAd,eAAwB,IAAAC,KAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,GAAAC,UAAAD,GACpBD,EAAUI,IAAI,SAAAC,GAAY,OAAAd,EAAOG,SAASK,UAAUM,MAM1Cd,EAAAe,iBAAd,WACI,OAAOf,EAAOG,SAASY,oBAM3Bd,OAAAC,eAAkBF,EAAA,aAAlB,WACI,OAAOA,EAAOG,SAASa,uCASbhB,EAAAiB,MAAd,SAAoBC,EAAiBC,QAAA,IAAAA,IAAAA,EAAA,GACjCnB,EAAOG,SAASiB,KAAMD,MAAOA,EAAOD,QAASA,KASnClB,EAAAqB,UAAd,SAAwBC,EAAWH,QAAA,IAAAA,IAAAA,EAAA,GAC/BnB,EAAOG,SAASiB,KAAMD,MAAOA,EAAOD,QAASK,KAAKC,UAAUF,MAQlDtB,EAAAoB,IAAd,SAAkBK,GACdzB,EAAOG,SAASiB,IAAIK,IAQVzB,EAAA0B,MAAd,SAAoBC,GAChB3B,EAAOG,SAASiB,KAAMQ,KAAMD,EAAKR,MAAK,EAAkBD,QAASS,EAAIT,WAE7ElB,EAlFA,GAoFAO,EAAA,WAEI,SAAAA,EAAmBH,EAAqDyB,QAArD,IAAAzB,IAAAA,EAAA,QAAqD,IAAAyB,IAAAA,MAArDC,KAAA1B,eAAAA,EAAqD0B,KAAAD,YAAAA,EAyB5E,OAvBWtB,EAAAwB,UAAAvB,UAAP,SAAiBM,GACbgB,KAAKD,YAAYG,KAAKlB,IAGnBP,EAAAwB,UAAAhB,iBAAP,WACI,IAAMkB,EAAIH,KAAKD,YAAYK,MAAM,GAEjC,OADAJ,KAAKD,YAAYjB,OAAS,EACnBqB,GAGXhC,OAAAC,eAAWK,EAAAwB,UAAA,aAAX,WACI,OAAOD,KAAKD,YAAYjB,wCAGrBL,EAAAwB,UAAAd,MAAP,SAAaC,EAAiBC,QAAA,IAAAA,IAAAA,EAAA,GAC1BW,KAAKV,KAAMD,MAAOA,EAAOD,QAASA,KAG/BX,EAAAwB,UAAAX,IAAP,SAAWK,QACc,IAAVA,GAAyBK,KAAK1B,gBAAkBqB,EAAMN,OAC7DW,KAAKD,YAAYhB,IAAI,SAAAsB,GAAc,OAAAA,EAAWf,IAAIK,MAG9DlB,EA3BA,GCxEA6B,EAAA,WAAA,SAAAA,KAuCA,OAhCWA,EAAAL,UAAAX,IAAP,SAAWK,GAEP,IAAMY,EAAMP,KAAKQ,OAAOb,GAExB,OAAQA,EAAMN,OACV,KAAA,EACA,KAAA,EACIoB,QAAQnB,IAAIiB,GACZ,MACJ,KAAA,EACIE,QAAQC,KAAKH,GACb,MACJ,KAAA,EACIE,QAAQb,MAAMW,KAUlBD,EAAAL,UAAAO,OAAR,SAAeb,GACX,IAAMY,KAMN,OALAA,EAAIL,KAAK,YAAcP,EAAMP,cACH,IAAfO,EAAMG,MACbS,EAAIL,KAAK,UAAYT,KAAKC,UAAUC,EAAMG,OAGvCS,EAAII,KAAK,KAExBL,EAvCA,GA6CAM,EAAA,WAQI,SAAAA,EAAoBC,GAAAb,KAAAa,OAAAA,EAUxB,OAHWD,EAAAX,UAAAX,IAAP,SAAWK,GACPK,KAAKa,OAAOlB,IAEpBiB,EAlBA","sourcesContent":["import { LogLevel } from \"./loglevel\";\nimport { LogListener } from \"./listeners\";\nimport { LogEntry } from \"./logentry\";\n\n/**\n * Class used to subscribe ILogListener and log messages throughout an application\n *\n */\nexport class Logger {\n\n    private static _instance: LoggerImpl;\n\n    /**\n     * Gets or sets the active log level to apply for log filtering\n     */\n    public static get activeLogLevel(): LogLevel {\n        return Logger.instance.activeLogLevel;\n    }\n\n    public static set activeLogLevel(value: LogLevel) {\n        Logger.instance.activeLogLevel = value;\n    }\n\n    private static get instance(): LoggerImpl {\n        if (typeof Logger._instance === \"undefined\" || Logger._instance === null) {\n            Logger._instance = new LoggerImpl();\n        }\n        return Logger._instance;\n    }\n\n    /**\n     * Adds ILogListener instances to the set of subscribed listeners\n     *\n     * @param listeners One or more listeners to subscribe to this log\n     */\n    public static subscribe(...listeners: LogListener[]): void {\n        listeners.map(listener => Logger.instance.subscribe(listener));\n    }\n\n    /**\n     * Clears the subscribers collection, returning the collection before modifiction\n     */\n    public static clearSubscribers(): LogListener[] {\n        return Logger.instance.clearSubscribers();\n    }\n\n    /**\n     * Gets the current subscriber count\n     */\n    public static get count(): number {\n        return Logger.instance.count;\n    }\n\n    /**\n     * Writes the supplied string to the subscribed listeners\n     *\n     * @param message The message to write\n     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Verbose)\n     */\n    public static write(message: string, level: LogLevel = LogLevel.Verbose) {\n        Logger.instance.log({ level: level, message: message });\n    }\n\n    /**\n     * Writes the supplied string to the subscribed listeners\n     *\n     * @param json The json object to stringify and write\n     * @param level [Optional] if supplied will be used as the level of the entry (Default: LogLevel.Verbose)\n     */\n    public static writeJSON(json: any, level: LogLevel = LogLevel.Verbose) {\n        Logger.instance.log({ level: level, message: JSON.stringify(json) });\n    }\n\n    /**\n     * Logs the supplied entry to the subscribed listeners\n     *\n     * @param entry The message to log\n     */\n    public static log(entry: LogEntry) {\n        Logger.instance.log(entry);\n    }\n\n    /**\n     * Logs an error object to the subscribed listeners\n     * \n     * @param err The error object\n     */\n    public static error(err: Error) {\n        Logger.instance.log({ data: err, level: LogLevel.Error, message: err.message });\n    }\n}\n\nclass LoggerImpl {\n\n    constructor(public activeLogLevel: LogLevel = LogLevel.Warning, private subscribers: LogListener[] = []) { }\n\n    public subscribe(listener: LogListener): void {\n        this.subscribers.push(listener);\n    }\n\n    public clearSubscribers(): LogListener[] {\n        const s = this.subscribers.slice(0);\n        this.subscribers.length = 0;\n        return s;\n    }\n\n    public get count(): number {\n        return this.subscribers.length;\n    }\n\n    public write(message: string, level: LogLevel = LogLevel.Verbose) {\n        this.log({ level: level, message: message });\n    }\n\n    public log(entry: LogEntry) {\n        if (typeof entry !== \"undefined\" && this.activeLogLevel <= entry.level) {\n            this.subscribers.map(subscriber => subscriber.log(entry));\n        }\n    }\n}\n","import { LogEntry } from \"./logentry\";\nimport { LogLevel } from \"./loglevel\";\n\n/**\n * Interface that defines a log listner\n *\n */\nexport interface LogListener {\n    /**\n     * Any associated data that a given logging listener may choose to log or ignore\n     *\n     * @param entry The information to be logged\n     */\n    log(entry: LogEntry): void;\n}\n\n/**\n * Implementation of LogListener which logs to the console\n *\n */\nexport class ConsoleListener implements LogListener {\n\n    /**\n     * Any associated data that a given logging listener may choose to log or ignore\n     *\n     * @param entry The information to be logged\n     */\n    public log(entry: LogEntry): void {\n\n        const msg = this.format(entry);\n\n        switch (entry.level) {\n            case LogLevel.Verbose:\n            case LogLevel.Info:\n                console.log(msg);\n                break;\n            case LogLevel.Warning:\n                console.warn(msg);\n                break;\n            case LogLevel.Error:\n                console.error(msg);\n                break;\n        }\n    }\n\n    /**\n     * Formats the message\n     *\n     * @param entry The information to format into a string\n     */\n    private format(entry: LogEntry): string {\n        const msg = [];\n        msg.push(\"Message: \" + entry.message);\n        if (typeof entry.data !== \"undefined\") {\n            msg.push(\" Data: \" + JSON.stringify(entry.data));\n        }\n\n        return msg.join(\"\");\n    }\n}\n\n/**\n * Implementation of LogListener which logs to the supplied function\n *\n */\nexport class FunctionListener implements LogListener {\n\n    /**\n     * Creates a new instance of the FunctionListener class\n     *\n     * @constructor\n     * @param  method The method to which any logging data will be passed\n     */\n    constructor(private method: (entry: LogEntry) => void) { }\n\n    /**\n     * Any associated data that a given logging listener may choose to log or ignore\n     *\n     * @param entry The information to be logged\n     */\n    public log(entry: LogEntry): void {\n        this.method(entry);\n    }\n}\n"]}