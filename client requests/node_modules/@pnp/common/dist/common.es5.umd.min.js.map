{"version":3,"sources":["../../../../packages/common/src/blobutil.ts","../../../../packages/common/src/collections.ts","../../../../packages/common/src/exceptions.ts","../../../../packages/common/src/libconfig.ts","../../../../packages/common/src/util.ts","../../../../packages/common/src/netutil.ts","../../../../packages/common/src/storage.ts","../../../../packages/common/src/decorators.ts"],"names":["readBlobAs","blob","mode","Promise","resolve","reject","reader","FileReader","onload","e","target","result","readAsText","readAsArrayBuffer","Dictionary","keys","values","this","prototype","get","key","index","indexOf","add","o","remove","push","merge","source","_this","sourceAsDictionary_1","getKeys","map","sourceAsHash","hasOwnProperty","val","splice","getValues","clear","Object","defineProperty","length","UrlException","_super","msg","call","name","Logger","log","data","level","message","tslib_1.__extends","Error","RuntimeConfigImpl","_v","extend","config","forEach","RuntimeConfig","getCtxCallback","context","method","params","_i","arguments","apply","dateAdd","date","interval","units","ret","Date","toLowerCase","setFullYear","getFullYear","setMonth","getMonth","setDate","getDate","setTime","getTime","undefined","combinePaths","paths","filter","path","Util","stringIsNullOrEmpty","replace","join","getRandomString","chars","text","Array","possible","i","charAt","Math","floor","random","getGUID","d","c","r","toString","isFunc","cf","objectDefinedNotNull","obj","isArray","array","constructor","noOverwrite","check","getOwnPropertyNames","v","reduce","t","isUrlAbsolute","url","test","s","Request","headers","value","append","FetchClient","fetch","options","global","BearerTokenFetchClient","_token","Headers","mergeHeaders","set","PnPClientStorageWrapper","store","defaultTimeoutMinutes","enabled","enableCacheExpiration","write","cacheExpirationHandler","getItem","persistable","JSON","parse","expiration","delete","put","expire","setItem","createPersistable","removeItem","getOrPut","getter","then","deleteExpired","defaultTimeout","defaultCachingTimeoutSeconds","stringify","pnp","_","setTimeout","cacheExpirationIntervalMilliseconds","catch","MemoryStorage","_store","count","PnPClientStorage","_local","_session","localStorage","sessionStorage","deprecationVersion","propertyKey","descriptor","args"],"mappings":"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","sourcesContent":["/**\n * Reads a blob as text\n *\n * @param blob The data to read\n */\nexport function readBlobAsText(blob: Blob): Promise<string> {\n    return readBlobAs<string>(blob, \"string\");\n}\n\n/**\n * Reads a blob into an array buffer\n *\n * @param blob The data to read\n */\nexport function readBlobAsArrayBuffer(blob: Blob): Promise<ArrayBuffer> {\n    return readBlobAs<ArrayBuffer>(blob, \"buffer\");\n}\n\n/**\n * Generic method to read blob's content\n *\n * @param blob The data to read\n * @param mode The read mode\n */\nfunction readBlobAs<T>(blob: Blob, mode: \"string\" | \"buffer\"): Promise<T> {\n\n    return new Promise<T>((resolve, reject) => {\n\n        try {\n\n            const reader = new FileReader();\n            reader.onload = (e: any) => {\n                resolve(e.target.result);\n            };\n\n            switch (mode) {\n                case \"string\":\n                    reader.readAsText(blob);\n                    break;\n                case \"buffer\":\n                    reader.readAsArrayBuffer(blob);\n                    break;\n            }\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n","/**\n * Interface defining an object with a known property type\n */\nexport interface TypedHash<T> {\n    [key: string]: T;\n}\n\n/**\n * Generic dictionary\n */\nexport class Dictionary<T> {\n\n    /**\n     * Creates a new instance of the Dictionary<T> class\n     *\n     * @constructor\n     */\n    constructor(private keys: string[] = [], private values: T[] = []) {\n    }\n\n    /**\n     * Gets a value from the collection using the specified key\n     *\n     * @param key The key whose value we want to return, returns null if the key does not exist\n     */\n    public get(key: string): T | null {\n        const index = this.keys.indexOf(key);\n        if (index < 0) {\n            return null;\n        }\n        return this.values[index];\n    }\n\n    /**\n     * Adds the supplied key and value to the dictionary\n     *\n     * @param key The key to add\n     * @param o The value to add\n     */\n    public add(key: string, o: T | null): void {\n        const index = this.keys.indexOf(key);\n        if (index > -1) {\n            if (o === null) {\n                this.remove(key);\n            } else {\n                this.values[index] = o;\n            }\n        } else {\n            if (o !== null) {\n                this.keys.push(key);\n                this.values.push(o);\n            }\n        }\n    }\n\n    /**\n     * Merges the supplied typed hash into this dictionary instance. Existing values are updated and new ones are created as appropriate.\n     */\n    public merge(source: TypedHash<T> | Dictionary<T>): void {\n        if (\"getKeys\" in source) {\n            const sourceAsDictionary = source as Dictionary<T>;\n            sourceAsDictionary.getKeys().map(key => {\n                this.add(key, sourceAsDictionary.get(key));\n            });\n        } else {\n            const sourceAsHash = source as TypedHash<T>;\n            for (const key in sourceAsHash) {\n                if (sourceAsHash.hasOwnProperty(key)) {\n                    this.add(key, sourceAsHash[key]);\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes a value from the dictionary\n     *\n     * @param key The key of the key/value pair to remove. Returns null if the key was not found.\n     */\n    public remove(key: string): T | null {\n        const index = this.keys.indexOf(key);\n        if (index < 0) {\n            return null;\n        }\n        const val = this.values[index];\n        this.keys.splice(index, 1);\n        this.values.splice(index, 1);\n        return val;\n    }\n\n    /**\n     * Returns all the keys currently in the dictionary as an array\n     */\n    public getKeys(): string[] {\n        return this.keys;\n    }\n\n    /**\n     * Returns all the values currently in the dictionary as an array\n     */\n    public getValues(): T[] {\n        return this.values;\n    }\n\n    /**\n     * Clears the current dictionary\n     */\n    public clear(): void {\n        this.keys = [];\n        this.values = [];\n    }\n\n    /**\n     * Gets a count of the items currently in the dictionary\n     */\n    public get count(): number {\n        return this.keys.length;\n    }\n}\n","import { Logger, LogLevel } from \"@pnp/logging\";\n\nexport class UrlException extends Error {\n\n    constructor(msg: string) {\n        super(msg);\n        this.name = \"UrlException\";\n        Logger.log({ data: {}, level: LogLevel.Error, message: `[${this.name}]::${this.message}` });\n    }\n}\n","import { TypedHash, Dictionary } from \"./collections\";\nimport { ISPFXContext } from \"./spfxContextInterface\";\n\nexport interface LibraryConfiguration {\n\n    /**\n     * Allows caching to be global disabled, default: false\n     */\n    globalCacheDisable?: boolean;\n\n    /**\n     * Defines the default store used by the usingCaching method, default: session\n     */\n    defaultCachingStore?: \"session\" | \"local\";\n\n    /**\n     * Defines the default timeout in seconds used by the usingCaching method, default 30\n     */\n    defaultCachingTimeoutSeconds?: number;\n\n    /**\n     * If true a timeout expired items will be removed from the cache in intervals determined by cacheTimeoutInterval\n     */\n    enableCacheExpiration?: boolean;\n\n    /**\n     * Determines the interval in milliseconds at which the cache is checked to see if items have expired (min: 100)\n     */\n    cacheExpirationIntervalMilliseconds?: number;\n\n    /**\n     * Used to supply the current context from an SPFx webpart to the library\n     */\n    spfxContext?: any;\n}\n\nexport function setup(config: LibraryConfiguration): void {\n    RuntimeConfig.extend(config);\n}\n\nexport class RuntimeConfigImpl {\n\n    private _v: Dictionary<any>;\n\n    constructor() {\n\n        this._v = new Dictionary();\n\n        // setup defaults\n        this._v.add(\"defaultCachingStore\", \"session\");\n        this._v.add(\"defaultCachingTimeoutSeconds\", 60);\n        this._v.add(\"globalCacheDisable\", false);\n        this._v.add(\"enableCacheExpiration\", false);\n        this._v.add(\"cacheExpirationIntervalMilliseconds\", 750);\n        this._v.add(\"spfxContext\", null);\n    }\n\n    /**\n     * \n     * @param config The set of properties to add to the globa configuration instance\n     */\n    public extend(config: TypedHash<any>): void {\n\n        Object.keys(config).forEach((key: string) => {\n            this._v.add(key, config[key]);\n        });\n    }\n\n    public get(key: string): any {\n        return this._v.get(key);\n    }\n\n    public get defaultCachingStore(): \"session\" | \"local\" {\n        return this.get(\"defaultCachingStore\");\n    }\n\n    public get defaultCachingTimeoutSeconds(): number {\n        return this.get(\"defaultCachingTimeoutSeconds\");\n    }\n\n    public get globalCacheDisable(): boolean {\n        return this.get(\"globalCacheDisable\");\n    }\n\n    public get enableCacheExpiration(): boolean {\n        return this.get(\"enableCacheExpiration\");\n    }\n\n    public get cacheExpirationIntervalMilliseconds(): number {\n        return this.get(\"cacheExpirationIntervalMilliseconds\");\n    }\n\n    public get spfxContext(): ISPFXContext {\n        return this.get(\"spfxContext\");\n    }\n}\n\nconst _runtimeConfig = new RuntimeConfigImpl();\n\nexport let RuntimeConfig = _runtimeConfig;\n","/**\n * Gets a callback function which will maintain context across async calls.\n * Allows for the calling pattern getCtxCallback(thisobj, method, methodarg1, methodarg2, ...)\n *\n * @param context The object that will be the 'this' value in the callback\n * @param method The method to which we will apply the context and parameters\n * @param params Optional, additional arguments to supply to the wrapped method when it is invoked\n */\nexport function getCtxCallback(context: any, method: Function, ...params: any[]): Function {\n    return function () {\n        method.apply(context, params);\n    };\n}\n\n/**\n * Adds a value to a date\n *\n * @param date The date to which we will add units, done in local time\n * @param interval The name of the interval to add, one of: ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second']\n * @param units The amount to add to date of the given interval\n *\n * http://stackoverflow.com/questions/1197928/how-to-add-30-minutes-to-a-javascript-date-object\n */\nexport function dateAdd(date: Date, interval: string, units: number): Date | undefined {\n    let ret: Date | undefined = new Date(date); // don't change original date\n    switch (interval.toLowerCase()) {\n        case \"year\": ret.setFullYear(ret.getFullYear() + units); break;\n        case \"quarter\": ret.setMonth(ret.getMonth() + 3 * units); break;\n        case \"month\": ret.setMonth(ret.getMonth() + units); break;\n        case \"week\": ret.setDate(ret.getDate() + 7 * units); break;\n        case \"day\": ret.setDate(ret.getDate() + units); break;\n        case \"hour\": ret.setTime(ret.getTime() + units * 3600000); break;\n        case \"minute\": ret.setTime(ret.getTime() + units * 60000); break;\n        case \"second\": ret.setTime(ret.getTime() + units * 1000); break;\n        default: ret = undefined; break;\n    }\n    return ret;\n}\n\n/**\n * Combines an arbitrary set of paths ensuring and normalizes the slashes\n *\n * @param paths 0 to n path parts to combine\n */\nexport function combinePaths(...paths: string[]): string {\n\n    return paths\n        .filter(path => !Util.stringIsNullOrEmpty(path))\n        .map(path => path.replace(/^[\\\\|\\/]/, \"\").replace(/[\\\\|\\/]$/, \"\"))\n        .join(\"/\")\n        .replace(/\\\\/g, \"/\");\n}\n\n/**\n * Gets a random string of chars length\n *\n * @param chars The length of the random string to generate\n */\nexport function getRandomString(chars: number): string {\n    const text = new Array(chars);\n    const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    for (let i = 0; i < chars; i++) {\n        text[i] = possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text.join(\"\");\n}\n\n/**\n * Gets a random GUID value\n *\n * http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n */\n/* tslint:disable no-bitwise */\nexport function getGUID(): string {\n    let d = new Date().getTime();\n    const guid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c === \"x\" ? r : (r & 0x3 | 0x8)).toString(16);\n    });\n    return guid;\n}\n/* tslint:enable */\n\n/**\n * Determines if a given value is a function\n *\n * @param cf The thing to test for functionness\n */\nexport function isFunc(cf: any): boolean {\n    return typeof cf === \"function\";\n}\n\n/**\n * Determines if an object is both defined and not null\n * @param obj Object to test\n */\nexport function objectDefinedNotNull(obj: any): boolean {\n    return typeof obj !== \"undefined\" && obj !== null;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n*/\nexport function isArray(array: any): boolean {\n\n    if (Array.isArray) {\n        return Array.isArray(array);\n    }\n\n    return array && typeof array.length === \"number\" && array.constructor === Array;\n}\n\n/**\n * Provides functionality to extend the given object by doing a shallow copy\n *\n * @param target The object to which properties will be copied\n * @param source The source object from which properties will be copied\n * @param noOverwrite If true existing properties on the target are not overwritten from the source\n *\n */\nexport function extend(target: any, source: any, noOverwrite = false): any {\n\n    if (!Util.objectDefinedNotNull(source)) {\n        return target;\n    }\n\n    // ensure we don't overwrite things we don't want overwritten\n    const check: (o: any, i: string) => Boolean = noOverwrite ? (o, i) => !(i in o) : () => true;\n\n    return Object.getOwnPropertyNames(source)\n        .filter((v: string) => check(target, v))\n        .reduce((t: any, v: string) => {\n            t[v] = source[v];\n            return t;\n        }, target);\n}\n\n/**\n * Determines if a given url is absolute\n *\n * @param url The url to check to see if it is absolute\n */\nexport function isUrlAbsolute(url: string): boolean {\n    return /^https?:\\/\\/|^\\/\\//i.test(url);\n}\n\n/**\n * Determines if a string is null or empty or undefined\n *\n * @param s The string to test\n */\nexport function stringIsNullOrEmpty(s: string): boolean {\n    return typeof s === \"undefined\" || s === null || s.length < 1;\n}\n\nexport class Util {\n\n    /**\n     * Gets a callback function which will maintain context across async calls.\n     * Allows for the calling pattern getCtxCallback(thisobj, method, methodarg1, methodarg2, ...)\n     *\n     * @param context The object that will be the 'this' value in the callback\n     * @param method The method to which we will apply the context and parameters\n     * @param params Optional, additional arguments to supply to the wrapped method when it is invoked\n     */\n    public static getCtxCallback = getCtxCallback;\n\n\n    /**\n     * Adds a value to a date\n     *\n     * @param date The date to which we will add units, done in local time\n     * @param interval The name of the interval to add, one of: ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second']\n     * @param units The amount to add to date of the given interval\n     *\n     * http://stackoverflow.com/questions/1197928/how-to-add-30-minutes-to-a-javascript-date-object\n     */\n    public static dateAdd = dateAdd;\n\n    /**\n     * Combines an arbitrary set of paths ensuring and normalizes the slashes\n     *\n     * @param paths 0 to n path parts to combine\n     */\n    public static combinePaths = combinePaths;\n\n    /**\n     * Gets a random string of chars length\n     *\n     * @param chars The length of the random string to generate\n     */\n    public static getRandomString = getRandomString;\n\n    /**\n     * Gets a random GUID value\n     *\n     * http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n     */\n    public static getGUID = getGUID;\n\n    /**\n     * Determines if a given value is a function\n     *\n     * @param cf The thing to test for functionness\n     */\n    public static isFunc = isFunc;\n\n    /**\n     * Determines if an object is both defined and not null\n     * @param obj Object to test\n     */\n    public static objectDefinedNotNull = objectDefinedNotNull;\n\n    /**\n     * @returns whether the provided parameter is a JavaScript Array or not.\n    */\n    public static isArray = isArray;\n\n    /**\n     * Provides functionality to extend the given object by doing a shallow copy\n     *\n     * @param target The object to which properties will be copied\n     * @param source The source object from which properties will be copied\n     * @param noOverwrite If true existing properties on the target are not overwritten from the source\n     *\n     */\n    public static extend = extend;\n\n    /**\n     * Determines if a given url is absolute\n     *\n     * @param url The url to check to see if it is absolute\n     */\n    public static isUrlAbsolute = isUrlAbsolute;\n\n    /**\n     * Determines if a string is null or empty or undefined\n     *\n     * @param s The string to test\n     */\n    public static stringIsNullOrEmpty = stringIsNullOrEmpty;\n}\n","import { Util } from \"./util\";\n\ndeclare var global: { fetch(url: string, options: any): Promise<Response> };\n\nexport interface ConfigOptions {\n    headers?: string[][] | { [key: string]: string } | Headers;\n    mode?: \"navigate\" | \"same-origin\" | \"no-cors\" | \"cors\";\n    credentials?: \"omit\" | \"same-origin\" | \"include\";\n    cache?: \"default\" | \"no-store\" | \"reload\" | \"no-cache\" | \"force-cache\" | \"only-if-cached\";\n}\n\nexport interface FetchOptions extends ConfigOptions {\n    method?: string;\n    body?: any;\n}\n\nexport interface HttpClientImpl {\n    fetch(url: string, options: FetchOptions): Promise<Response>;\n}\n\nexport interface RequestClient {\n    fetch(url: string, options?: FetchOptions): Promise<Response>;\n    fetchRaw(url: string, options?: FetchOptions): Promise<Response>;\n    get(url: string, options?: FetchOptions): Promise<Response>;\n    post(url: string, options?: FetchOptions): Promise<Response>;\n    patch(url: string, options?: FetchOptions): Promise<Response>;\n    delete(url: string, options?: FetchOptions): Promise<Response>;\n}\n\nexport function mergeHeaders(target: Headers, source: any): void {\n    if (typeof source !== \"undefined\" && source !== null) {\n        const temp = <any>new Request(\"\", { headers: source });\n        temp.headers.forEach((value: string, name: string) => {\n            target.append(name, value);\n        });\n    }\n}\n\nexport function mergeOptions(target: ConfigOptions, source: ConfigOptions): void {\n\n    if (Util.objectDefinedNotNull(source)) {\n        const headers = Util.extend(target.headers || {}, source.headers);\n        target = Util.extend(target, source);\n        target.headers = headers;\n    }\n}\n\n/**\n * Makes requests using the global/window fetch API\n */\nexport class FetchClient implements HttpClientImpl {\n    public fetch(url: string, options: FetchOptions): Promise<Response> {\n        return global.fetch(url, options);\n    }\n}\n\n/**\n * Makes requests using the fetch API adding the supplied token to the Authorization header\n */\nexport class BearerTokenFetchClient extends FetchClient {\n\n    constructor(private _token: string) {\n        super();\n    }\n\n    public fetch(url: string, options: FetchOptions = {}): Promise<Response> {\n\n        const headers = new Headers();\n\n        mergeHeaders(headers, options.headers);\n\n        headers.set(\"Authorization\", `Bearer ${this._token}`);\n\n        options.headers = headers;\n\n        return super.fetch(url, options);\n    }\n}\n","import { Util } from \"./util\";\nimport { Dictionary } from \"./collections\";\nimport { RuntimeConfig } from \"./libconfig\";\nimport { Logger, LogLevel } from \"@pnp/logging\";\n\n/**\n * A wrapper class to provide a consistent interface to browser based storage\n *\n */\nexport class PnPClientStorageWrapper implements PnPClientStore {\n\n    /**\n     * True if the wrapped storage is available; otherwise, false\n     */\n    public enabled: boolean;\n\n    /**\n     * Creates a new instance of the PnPClientStorageWrapper class\n     *\n     * @constructor\n     */\n    constructor(private store: Storage, public defaultTimeoutMinutes = -1) {\n        this.enabled = this.test();\n        // if the cache timeout is enabled call the handler\n        // this will clear any expired items and set the timeout function\n        if (RuntimeConfig.enableCacheExpiration) {\n            Logger.write(`Enabling cache expiration.`, LogLevel.Info);\n            this.cacheExpirationHandler();\n        }\n    }\n\n    /**\n     * Get a value from storage, or null if that value does not exist\n     *\n     * @param key The key whose value we want to retrieve\n     */\n    public get<T>(key: string): T | null {\n\n        if (!this.enabled) {\n            return null;\n        }\n\n        const o = this.store.getItem(key);\n\n        if (o == null) {\n            return null;\n        }\n\n        const persistable = JSON.parse(o);\n\n        if (new Date(persistable.expiration) <= new Date()) {\n\n            Logger.write(`Removing item with key '${key}' from cache due to expiration.`, LogLevel.Info);\n            this.delete(key);\n            return null;\n\n        } else {\n\n            return persistable.value as T;\n        }\n    }\n\n    /**\n     * Adds a value to the underlying storage\n     *\n     * @param key The key to use when storing the provided value\n     * @param o The value to store\n     * @param expire Optional, if provided the expiration of the item, otherwise the default is used\n     */\n    public put(key: string, o: any, expire?: Date): void {\n        if (this.enabled) {\n            this.store.setItem(key, this.createPersistable(o, expire));\n        }\n    }\n\n    /**\n     * Deletes a value from the underlying storage\n     *\n     * @param key The key of the pair we want to remove from storage\n     */\n    public delete(key: string): void {\n        if (this.enabled) {\n            this.store.removeItem(key);\n        }\n    }\n\n    /**\n     * Gets an item from the underlying storage, or adds it if it does not exist using the supplied getter function\n     *\n     * @param key The key to use when storing the provided value\n     * @param getter A function which will upon execution provide the desired value\n     * @param expire Optional, if provided the expiration of the item, otherwise the default is used\n     */\n    public getOrPut<T>(key: string, getter: () => Promise<T>, expire?: Date): Promise<T> {\n        if (!this.enabled) {\n            return getter();\n        }\n\n        return new Promise((resolve) => {\n\n            const o = this.get<T>(key);\n\n            if (o == null) {\n                getter().then((d) => {\n                    this.put(key, d, expire);\n                    resolve(d);\n                });\n            } else {\n                resolve(o);\n            }\n        });\n    }\n\n    /**\n     * Deletes any expired items placed in the store by the pnp library, leaves other items untouched\n     */\n    public deleteExpired(): Promise<void> {\n\n        return new Promise<void>((resolve, reject) => {\n\n            if (!this.enabled) {\n                resolve();\n            }\n\n            try {\n\n                for (let i = 0; i < this.store.length; i++) {\n                    const key = this.store.key(i);\n                    if (key !== null) {\n                        // test the stored item to see if we stored it\n                        if (/[\"|']?pnp[\"|']? ?: ?1/i.test(<string>this.store.getItem(key))) {\n                            // get those items as get will delete from cache if they are expired\n                            this.get(key);\n                        }\n                    }\n                }\n\n                resolve();\n\n            } catch (e) { reject(e); }\n        });\n    }\n\n    /**\n     * Used to determine if the wrapped storage is available currently\n     */\n    private test(): boolean {\n        const str = \"test\";\n        try {\n            this.store.setItem(str, str);\n            this.store.removeItem(str);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Creates the persistable to store\n     */\n    private createPersistable(o: any, expire?: Date): string {\n        if (typeof expire === \"undefined\") {\n\n            // ensure we are by default inline with the global library setting\n            let defaultTimeout = RuntimeConfig.defaultCachingTimeoutSeconds;\n            if (this.defaultTimeoutMinutes > 0) {\n                defaultTimeout = this.defaultTimeoutMinutes * 60;\n            }\n            expire = Util.dateAdd(new Date(), \"second\", defaultTimeout);\n        }\n\n        return JSON.stringify({ pnp: 1, expiration: expire, value: o });\n    }\n\n    /**\n     * Deletes expired items added by this library in this.store and sets a timeout to call itself\n     */\n    private cacheExpirationHandler(): void {\n\n        Logger.write(\"Called cache expiration handler.\", LogLevel.Verbose);\n        this.deleteExpired().then(_ => {\n\n            // call ourself in the future\n            setTimeout(Util.getCtxCallback(this, this.cacheExpirationHandler), RuntimeConfig.cacheExpirationIntervalMilliseconds);\n        }).catch(e => {\n\n            // we've got some error - so just stop the loop and report the error\n            Logger.log({\n                data: e,\n                level: LogLevel.Error,\n                message: \"Error deleting expired cache entries, see data for details. Timeout not reset.\",\n            });\n        });\n    }\n}\n\n/**\n * Interface which defines the operations provided by a client storage object\n */\nexport interface PnPClientStore {\n    /**\n     * True if the wrapped storage is available; otherwise, false\n     */\n    enabled: boolean;\n\n    /**\n     * Get a value from storage, or null if that value does not exist\n     *\n     * @param key The key whose value we want to retrieve\n     */\n    get(key: string): any;\n\n    /**\n     * Adds a value to the underlying storage\n     *\n     * @param key The key to use when storing the provided value\n     * @param o The value to store\n     * @param expire Optional, if provided the expiration of the item, otherwise the default is used\n     */\n    put(key: string, o: any, expire?: Date): void;\n\n    /**\n     * Deletes a value from the underlying storage\n     *\n     * @param key The key of the pair we want to remove from storage\n     */\n    delete(key: string): void;\n\n    /**\n     * Gets an item from the underlying storage, or adds it if it does not exist using the supplied getter function\n     *\n     * @param key The key to use when storing the provided value\n     * @param getter A function which will upon execution provide the desired value\n     * @param expire Optional, if provided the expiration of the item, otherwise the default is used\n     */\n    getOrPut(key: string, getter: Function, expire?: Date): any;\n\n    /**\n     * Removes any expired items placed in the store by the pnp library, leaves other items untouched\n     */\n    deleteExpired(): Promise<void>;\n}\n\n/**\n * A thin implementation of in-memory storage for use in nodejs\n */\nclass MemoryStorage {\n\n    constructor(private _store = new Dictionary<string>()) { }\n\n    public get length(): number {\n        return this._store.count;\n    }\n\n    public clear(): void {\n        this._store.clear();\n    }\n\n    public getItem(key: string): any {\n        return this._store.get(key);\n    }\n\n    public key(index: number): string {\n        return this._store.getKeys()[index];\n    }\n\n    public removeItem(key: string): void {\n        this._store.remove(key);\n    }\n\n    public setItem(key: string, data: string): void {\n        this._store.add(key, data);\n    }\n\n    [key: string]: any;\n    [index: number]: string;\n}\n\n/**\n * A class that will establish wrappers for both local and session storage\n */\nexport class PnPClientStorage {\n\n    /**\n     * Creates a new instance of the PnPClientStorage class\n     *\n     * @constructor\n     */\n    constructor(private _local: PnPClientStore | null = null, private _session: PnPClientStore | null = null) { }\n\n    /**\n     * Provides access to the local storage of the browser\n     */\n    public get local(): PnPClientStore {\n\n        if (this._local === null) {\n            this._local = typeof localStorage !== \"undefined\" ? new PnPClientStorageWrapper(localStorage) : new PnPClientStorageWrapper(new MemoryStorage());\n        }\n\n        return this._local;\n    }\n\n    /**\n     * Provides access to the session storage of the browser\n     */\n    public get session(): PnPClientStore {\n\n        if (this._session === null) {\n            this._session = typeof sessionStorage !== \"undefined\" ? new PnPClientStorageWrapper(sessionStorage) : new PnPClientStorageWrapper(new MemoryStorage());\n        }\n\n        return this._session;\n    }\n}\n","import { Logger, LogLevel } from \"@pnp/logging\";\n\nexport function deprecated(deprecationVersion: string, message: string) {\n\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n\n        const method = descriptor.value;\n\n        descriptor.value = function (this: any, ...args: any[]) {\n            Logger.log({\n                data: {\n                    descriptor: descriptor,\n                    propertyKey: propertyKey,\n                    target: target,\n                },\n                level: LogLevel.Warning,\n                message: `(${deprecationVersion}) ${message}`,\n            });\n\n            return method.apply(this, args);\n        };\n    };\n}\n\nexport function beta(message = \"This feature is flagged as beta and is subject to change.\") {\n\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n\n        const method = descriptor.value;\n\n        descriptor.value = function (this: any, ...args: any[]) {\n            Logger.log({\n                data: {\n                    descriptor: descriptor,\n                    propertyKey: propertyKey,\n                    target: target,\n                },\n                level: LogLevel.Warning,\n                message: message,\n            });\n\n            return method.apply(this, args);\n        };\n    };\n}\n"]}