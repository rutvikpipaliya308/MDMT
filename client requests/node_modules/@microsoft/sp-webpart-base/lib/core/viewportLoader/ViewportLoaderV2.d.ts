/**
 * For reviewers: This second version of ViewportLoader was created to help transition
 * from a web part specific loader to a web part agnostic one. This loader avoids the
 * explicit use of web parts, but uses the same logic. Next PR will introduce a viewport
 * loader manager for viewport loaders of different types.
 */
import IViewportAwareComponent from './IViewportAwareComponent';
import IViewportLoader from './IViewportLoader';
/**
 * Class that helps lazy loading of components. This class centrally manages
 * registered components to be rendered lazily when in the viewport, i.e. Components
 * that are not in the viewport will not be rendered on the initial load. They will
 * be rendered only when the user scrolls to the component. This class manages the
 * scroll/resize event handling and notification to the components to render when
 * they are near the viewport.
 *
 * E.g. Modern pages' components in viewport will be loaded. All other components are
 * lazily loaded when the user scrolls the viewport and that particular component is
 * in the view.
 *
 * @internal
 */
export default class ViewportLoader implements IViewportLoader<IViewportAwareComponent> {
    /**
     * Singleton instance of the Viewport loader
     */
    private static _instance;
    /**
     * Switch to turn optimization on/off. Will be controlled by the ViewportLoaderManager.
     */
    private static _simpleLoad;
    /**
     * The type of components being registered in the viewport. Used for telemetry.
     */
    private static _eventNamePrefix;
    /**
     * There are features which loads IntersectionObserver polyfill in lazy manner.
     * We don't want to be confused with that. Find support status at start and just stick to that.
     */
    private static _useIntersectionObserver;
    /**
     * Registered components.
     */
    private _components;
    private _observerMap;
    /**
     * This attribute managed the number of scroll event handlers that are registered to
     * a scrollable parent. When the number of events becomes zero, the event handler is
     * unregistered.
     */
    private readonly LAZY_LOADED_TRACKER_ATTRIBUTE;
    private readonly SCROLL;
    private readonly RESIZE;
    /**
     * This is a throttled version of the lazy event handler. This is used to make sure
     * we do not call the scroll event handler too often.
     */
    private _lazyHandler;
    private _isInitialized;
    private _logSource;
    private _initTime;
    private _isListeningWindow;
    private _observer;
    /**
     * These are the components being loaded proactively by increasing viewport offset.
     * It is used to track when all are rendered so viewport offset can be increased further.
     */
    private _offsetComponentsToLoad;
    /**
     * Offset from the viewport which will be considered for loading
     */
    private _offset;
    /**
     * When true, components outside the viewport will also be loaded immediately.
     */
    private isViewportLoaded;
    /**
     * Returns the singleton instance of the viewport loader.
     * @param simpleLoad If true, avoid the intersection observer optimization
     */
    static getInstance(eventNamePrefix: string, simpleLoad?: boolean): ViewportLoader;
    static optimizeViewportLoader(): boolean;
    /**
     * Determines if a component should be lazily loaded and registers such components.
     */
    register(component: IViewportAwareComponent, scrollableParent?: HTMLElement): void;
    /**
     * Render component if in the waiting queue of viewport loader
     * @param component
     */
    release(component: IViewportAwareComponent): boolean;
    /**
     * Unregister a loaded component which should not be tracked any more.
     */
    unregister(component: IViewportAwareComponent): void;
    /**
     * Load registered components not in the viewport, by gradually increasing viewport offset.
     */
    loadOutsideViewPort(): void;
    /**
    * Private Constructor of singleton class
    */
    private constructor();
    /**
     * Bind all functions to this instance
     */
    private _bind;
    /**
     * Event handler which is called upon scroll and resize events.
     */
    private _lazyLoaderEventHandler;
    private _loadComponentsInViewport;
    /**
    * Handler to start rendering component if it is close enough to the viewport.
    */
    private _checkVisibilityAndRender;
    private _onObserved;
    /**
    * Check if component is close enough to the viewport to be shown.
    */
    private _isCloseToViewport;
    /**
    * Returns all scrollable parent DOM Elements of the given element
    */
    private _findScrollableParents;
    /**
     * Traverses up the DOM tree for the element with the data-is-scrollable=true attribute,
     * or return the window object.
     */
    private _findScrollableParent;
    private _initialize;
    private _dispose;
    /**
    * Start listening to scroll and resize events. It is safe to call this API multiple times on a DOM
    * element, it does not lead to multiple attached events.
    */
    private _listenEvents;
    /**
     * Add Listener to scroll and resize events for given element or window
     */
    private _addEventListerer;
    /**
    * Stop listening to scroll and resize events.
    */
    private _unlistenEvents;
    /**
     * Remove Listeners from scroll and resize events for given element or window
     */
    private _removeEventListener;
    /**
     * It keeps track of how many lazily loaded children are registered to a scrollable parent.
     * This record keeping is required to deregister event handler from the parent when There
     * are no children listening to events.
     */
    private _updateRegisteredChildren;
    /**
     * Ask component to load.
     */
    private _renderComponentInViewport;
    /**
     * Load registered components not in the viewport, by gradually increasing viewport offset.
     * It also tracks when components are rendered to reduce the gap between increasing offset
     */
    private _loadOutsideViewPort;
}
//# sourceMappingURL=ViewportLoaderV2.d.ts.map