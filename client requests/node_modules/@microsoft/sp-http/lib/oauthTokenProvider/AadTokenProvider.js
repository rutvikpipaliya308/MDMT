import * as tslib_1 from "tslib";
import { Guid, SPEvent, SPEventArgs, Validate, _SPKillSwitch } from '@microsoft/sp-core-library';
import AdalAuthContextManager from './AdalAuthContextManager';
import strings from '../SPHttpStrings.resx';
var TokenAcquisitionEventArgs =  (function (_super) {
    tslib_1.__extends(TokenAcquisitionEventArgs, _super);
    function TokenAcquisitionEventArgs(message, redirectUrl) {
        var _this = _super.call(this) || this;
        _this.message = message;
        _this.redirectUrl = redirectUrl;
        return _this;
    }
    return TokenAcquisitionEventArgs;
}(SPEventArgs));
export { TokenAcquisitionEventArgs };
var AadTokenProvider =  (function () {
    function AadTokenProvider(configuration, oboConfiguration) {
        Validate.isNonemptyString(configuration.aadInstanceUrl, 'aadInstanceUrl');
        Validate.isNonemptyString(configuration.aadTenantId, 'aadTenantId');
        Validate.isNonemptyString(configuration.redirectUri, 'redirectUri');
        Validate.isNonemptyString(configuration.servicePrincipalId, 'servicePrincipalId');
        this._defaultConfiguration = configuration;
        this._fetchQueue = Promise.resolve();
        this._oboConfiguration = oboConfiguration;
        this._tokenAcquisitionEvent = new SPEvent(AadTokenProvider._tokenAcquisitionEventId);
    }
    AadTokenProvider.prototype.getToken = function (resourceEndpoint, useCachedToken) {
        if (useCachedToken === void 0) { useCachedToken = true; }
        if (this._defaultConfiguration.servicePrincipalId === Guid.empty.toString()) {
            return Promise.reject(new Error(strings.servicePrincipalNotAvaliableError));
        }
        return this._getTokenInternal(resourceEndpoint, this._defaultConfiguration, useCachedToken);
    };
    AadTokenProvider.prototype._getTokenInternal = function (resourceEndpoint, configuration, useCachedToken) {
        var _this = this;
        if (useCachedToken === void 0) { useCachedToken = true; }
        var tokenProviderConfig = configuration || this._defaultConfiguration;
        if (!this._authContextManager) {
            this._authContextManager = new AdalAuthContextManager();
        }
        if (!_SPKillSwitch.isActivated(AadTokenProvider.removeSerialRequestsKillSwitchGuid, '05/13/19', 'Without ID Tokens, we no longer need to request tokens in parallel')) {
            return this._authContextManager.getAuthContext(tokenProviderConfig, this._oboConfiguration)
                .then(function (authContext) { return authContext.getToken(resourceEndpoint, useCachedToken); });
        }
        else {
            var getAuthContextPromise = function () { return _this._authContextManager.getAuthContext(tokenProviderConfig, _this._oboConfiguration); };
            this._fetchQueue =
                this._fetchQueue
                    .then(getAuthContextPromise, getAuthContextPromise)
                    .then(function (authContext) { return authContext.getToken(resourceEndpoint, useCachedToken); });
            return this._fetchQueue;
        }
    };
    Object.defineProperty(AadTokenProvider.prototype, "tokenAcquisitionEvent", {
        get: function () {
            return this._tokenAcquisitionEvent;
        },
        enumerable: true,
        configurable: true
    });
    AadTokenProvider._tokenAcquisitionEventId = 'tokenAcquisitionFailure';
    AadTokenProvider.removeSerialRequestsKillSwitchGuid = Guid.parse('d6f1838d-2b33-4c10-8c51-f61b13d20a61');
    return AadTokenProvider;
}());
export default AadTokenProvider;
