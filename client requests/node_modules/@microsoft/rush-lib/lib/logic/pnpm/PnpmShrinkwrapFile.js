"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yaml = require("js-yaml");
const os = require("os");
const semver = require("semver");
const node_core_library_1 = require("@microsoft/node-core-library");
const BaseShrinkwrapFile_1 = require("../base/BaseShrinkwrapFile");
// This is based on PNPM's own configuration:
// https://github.com/pnpm/pnpm-shrinkwrap/blob/master/src/write.ts
const SHRINKWRAP_YAML_FORMAT = {
    lineWidth: 1000,
    noCompatMode: true,
    noRefs: true,
    sortKeys: true
};
/**
 * Given an encoded "dependency path" from the PNPM shrinkwrap file, this extracts the version component.
 * @returns a SemVer string, or undefined if the version specifier cannot be parsed
 */
function extractVersionFromPnpmVersionSpecifier(version) {
    if (!version) {
        return undefined;
    }
    // Does the string contain any slashes?
    const versionParts = version.split('/');
    if (versionParts.length === 1) {
        // No slashes
        // Does it contain the V5 underscore delimiter?
        const underscoreIndex = version.indexOf('_');
        if (underscoreIndex >= 0) {
            // This form was introduced in PNPM 3 (lockfile version 5):
            //
            // Example: "23.6.0_babel-core@6.26.3"
            // Example: "1.0.7_request@2.88.0"
            // Example: "1.0.3_@pnpm+logger@1.0.2"
            return version.substr(0, underscoreIndex); // e.g. "23.6.0"
        }
        else {
            // It is a simple version.
            //
            // Example: "0.0.5"
            return version;
        }
    }
    // Does it contain an NPM scope?
    const isScoped = versionParts[1].indexOf('@') === 0;
    if (versionParts.length === 4 && !isScoped) {
        // Example: "/gulp-karma/0.0.5/karma@0.13.22"
        // Example: "/sinon-chai/2.8.0/chai@3.5.0+sinon@1.17.7")
        return versionParts[2]; // e.g. "0.0.5"
    }
    if (versionParts.length === 5 && isScoped) {
        // Example: "/@ms/sp-client-utilities/3.1.1/foo@13.1.0"
        return versionParts[3]; // e.g. "3.1.1"
    }
    if (semver.valid(versionParts[versionParts.length - 1]) !== null) {
        // Example: "path.pkgs.visualstudio.com/@scope/depame/1.4.0"
        return versionParts[versionParts.length - 1]; // e.g. "1.4.0"
    }
    return undefined;
}
exports.extractVersionFromPnpmVersionSpecifier = extractVersionFromPnpmVersionSpecifier;
class PnpmShrinkwrapFile extends BaseShrinkwrapFile_1.BaseShrinkwrapFile {
    static loadFromFile(shrinkwrapYamlFilename) {
        try {
            if (!node_core_library_1.FileSystem.exists(shrinkwrapYamlFilename)) {
                return undefined; // file does not exist
            }
            // We don't use JsonFile/jju here because shrinkwrap.json is a special NPM file format
            // and typically very large, so we want to load it the same way that NPM does.
            const parsedData = yaml.safeLoad(node_core_library_1.FileSystem.readFile(shrinkwrapYamlFilename).toString());
            return new PnpmShrinkwrapFile(parsedData);
        }
        catch (error) {
            throw new Error(`Error reading "${shrinkwrapYamlFilename}":` + os.EOL + `  ${error.message}`);
        }
    }
    getTempProjectNames() {
        return this._getTempProjectNames(this._shrinkwrapJson.dependencies);
    }
    /**
     * Serializes the PNPM Shrinkwrap file
     */
    serialize() {
        return yaml.safeDump(this._shrinkwrapJson, SHRINKWRAP_YAML_FORMAT);
    }
    /**
     * Gets the version number from the list of top-level dependencies in the "dependencies" section
     * of the shrinkwrap file
     */
    getTopLevelDependencyVersion(dependencyName) {
        return BaseShrinkwrapFile_1.BaseShrinkwrapFile.tryGetValue(this._shrinkwrapJson.dependencies, dependencyName);
    }
    /**
     * Gets the resolved version number of a dependency for a specific temp project.
     * For PNPM, we can reuse the version that another project is using.
     * Note that this function modifies the shrinkwrap data.
     */
    tryEnsureDependencyVersion(dependencyName, tempProjectName, versionRange) {
        // PNPM doesn't have the same advantage of NPM, where we can skip generate as long as the
        // shrinkwrap file puts our dependency in either the top of the node_modules folder
        // or underneath the package we are looking at.
        // This is because the PNPM shrinkwrap file describes the exact links that need to be created
        // to recreate the graph..
        // Because of this, we actually need to check for a version that this package is directly
        // linked to.
        const tempProjectDependencyKey = this._getTempProjectKey(tempProjectName);
        const packageDescription = this._getPackageDescription(tempProjectDependencyKey);
        if (!packageDescription) {
            return undefined;
        }
        if (!packageDescription.dependencies.hasOwnProperty(dependencyName)) {
            if (versionRange) {
                // this means the current temp project doesn't provide this dependency,
                // however, we may be able to use a different version. we prefer the latest version
                let latestVersion = undefined;
                this.getTempProjectNames().forEach((otherTempProject) => {
                    const otherVersion = this._getDependencyVersion(dependencyName, otherTempProject);
                    if (otherVersion && semver.satisfies(otherVersion, versionRange)) {
                        if (!latestVersion || semver.gt(otherVersion, latestVersion)) {
                            latestVersion = otherVersion;
                        }
                    }
                });
                if (latestVersion) {
                    // go ahead and fixup the shrinkwrap file to point at this
                    const dependencies = this._shrinkwrapJson.packages[tempProjectDependencyKey].dependencies || {};
                    dependencies[dependencyName] = latestVersion;
                    this._shrinkwrapJson.packages[tempProjectDependencyKey].dependencies = dependencies;
                    return latestVersion;
                }
            }
            return undefined;
        }
        return this._normalizeDependencyVersion(dependencyName, packageDescription.dependencies[dependencyName]);
    }
    checkValidVersionRange(dependencyVersion, versionRange) {
        // dependencyVersion could be a relative or absolute path, for those cases we
        // need to extract the version from the end of the path.
        return super.checkValidVersionRange(dependencyVersion.split('/').pop(), versionRange);
    }
    constructor(shrinkwrapJson) {
        super();
        this._shrinkwrapJson = shrinkwrapJson;
        // Normalize the data
        if (!this._shrinkwrapJson.registry) {
            this._shrinkwrapJson.registry = '';
        }
        if (!this._shrinkwrapJson.dependencies) {
            this._shrinkwrapJson.dependencies = {};
        }
        if (!this._shrinkwrapJson.specifiers) {
            this._shrinkwrapJson.specifiers = {};
        }
        if (!this._shrinkwrapJson.packages) {
            this._shrinkwrapJson.packages = {};
        }
    }
    /**
     * Returns the version of a dependency being used by a given project
     */
    _getDependencyVersion(dependencyName, tempProjectName) {
        const tempProjectDependencyKey = this._getTempProjectKey(tempProjectName);
        const packageDescription = this._getPackageDescription(tempProjectDependencyKey);
        if (!packageDescription) {
            return undefined;
        }
        if (!packageDescription.dependencies.hasOwnProperty(dependencyName)) {
            return undefined;
        }
        return this._normalizeDependencyVersion(dependencyName, packageDescription.dependencies[dependencyName]);
    }
    /**
     * Gets the package description for a tempProject from the shrinkwrap file.
     */
    _getPackageDescription(tempProjectDependencyKey) {
        const packageDescription = BaseShrinkwrapFile_1.BaseShrinkwrapFile.tryGetValue(this._shrinkwrapJson.packages, tempProjectDependencyKey);
        if (!packageDescription || !packageDescription.dependencies) {
            return undefined;
        }
        return packageDescription;
    }
    _getTempProjectKey(tempProjectName) {
        // Example: "project1"
        const unscopedTempProjectName = node_core_library_1.PackageName.getUnscopedName(tempProjectName);
        return `file:projects/${unscopedTempProjectName}.tgz`;
    }
    _normalizeDependencyVersion(dependencyName, version) {
        if (version) {
            const extractedVersion = extractVersionFromPnpmVersionSpecifier(version);
            if (!extractedVersion) {
                throw new Error(`Cannot parse pnpm shrinkwrap version specifier: `
                    + `"${version}" for "${dependencyName}"`);
            }
            return extractedVersion;
        }
        else {
            return undefined;
        }
    }
}
exports.PnpmShrinkwrapFile = PnpmShrinkwrapFile;
//# sourceMappingURL=PnpmShrinkwrapFile.js.map