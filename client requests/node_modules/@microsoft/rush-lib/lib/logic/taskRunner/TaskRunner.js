"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const stream_collator_1 = require("@microsoft/stream-collator");
const node_core_library_1 = require("@microsoft/node-core-library");
const Stopwatch_1 = require("../../utilities/Stopwatch");
const TaskStatus_1 = require("./TaskStatus");
const AlreadyReportedError_1 = require("../../utilities/AlreadyReportedError");
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Any class of task definition may be registered, and dependencies between tasks are
 * easily specified. Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail.
 */
class TaskRunner {
    constructor(options) {
        const { quietMode, parallelism, changedProjectsOnly, allowWarningsInSuccessfulBuild, terminal = new node_core_library_1.Terminal(new node_core_library_1.ConsoleTerminalProvider()) } = options;
        this._tasks = new Map();
        this._buildQueue = [];
        this._quietMode = quietMode;
        this._hasAnyFailures = false;
        this._hasAnyWarnings = false;
        this._changedProjectsOnly = changedProjectsOnly;
        this._allowWarningsInSuccessfulBuild = allowWarningsInSuccessfulBuild;
        this._terminal = terminal;
        const numberOfCores = os.cpus().length;
        if (parallelism) {
            if (parallelism === 'max') {
                this._parallelism = numberOfCores;
            }
            else {
                const parallelismInt = parseInt(parallelism, 10);
                if (isNaN(parallelismInt)) {
                    throw new Error(`Invalid parallelism value of '${parallelism}', expected a number or 'max'`);
                }
                this._parallelism = parallelismInt;
            }
        }
        else {
            // If an explicit parallelism number wasn't provided, then choose a sensible
            // default.
            if (os.platform() === 'win32') {
                // On desktop Windows, some people have complained that their system becomes
                // sluggish if Rush is using all the CPU cores.  Leave one thread for
                // other operations. For CI environments, you can use the "max" argument to use all available cores.
                this._parallelism = Math.max(numberOfCores - 1, 1);
            }
            else {
                // Unix-like operating systems have more balanced scheduling, so default
                // to the number of CPU cores
                this._parallelism = numberOfCores;
            }
        }
    }
    /**
     * Registers a task definition to the map of defined tasks
     */
    addTask(taskDefinition) {
        if (this._tasks.has(taskDefinition.name)) {
            throw new Error('A task with that name has already been registered.');
        }
        const task = taskDefinition;
        task.dependencies = new Set();
        task.dependents = new Set();
        task.status = TaskStatus_1.TaskStatus.Ready;
        task.criticalPathLength = undefined;
        this._tasks.set(task.name, task);
        if (!this._quietMode) {
            this._terminal.writeLine(`Registered ${task.name}`);
        }
    }
    /**
     * Returns true if a task with that name has been registered
     */
    hasTask(taskName) {
        return this._tasks.has(taskName);
    }
    /**
     * Defines the list of dependencies for an individual task.
     * @param taskName - the string name of the task for which we are defining dependencies. A task with this
     * name must already have been registered.
     */
    addDependencies(taskName, taskDependencies) {
        const task = this._tasks.get(taskName);
        if (!task) {
            throw new Error(`The task '${taskName}' has not been registered`);
        }
        if (!taskDependencies) {
            throw new Error('The list of dependencies must be defined');
        }
        for (const dependencyName of taskDependencies) {
            if (!this._tasks.has(dependencyName)) {
                throw new Error(`The project '${dependencyName}' has not been registered.`);
            }
            const dependency = this._tasks.get(dependencyName);
            task.dependencies.add(dependency);
            dependency.dependents.add(task);
        }
    }
    /**
     * Executes all tasks which have been registered, returning a promise which is resolved when all the
     * tasks are completed successfully, or rejects when any task fails.
     */
    execute() {
        this._currentActiveTasks = 0;
        this._completedTasks = 0;
        this._totalTasks = this._tasks.size;
        this._terminal.writeLine(`Executing a maximum of ${this._parallelism} simultaneous processes...${os.EOL}`);
        this._checkForCyclicDependencies(this._tasks.values(), []);
        // Precalculate the number of dependent packages
        this._tasks.forEach((task) => {
            this._calculateCriticalPaths(task);
        });
        // Add everything to the buildQueue
        this._tasks.forEach((task) => {
            this._buildQueue.push(task);
        });
        // Sort the queue in descending order, nothing will mess with the order
        this._buildQueue.sort((taskA, taskB) => {
            return taskB.criticalPathLength - taskA.criticalPathLength;
        });
        return this._startAvailableTasks().then(() => {
            this._printTaskStatus();
            if (this._hasAnyFailures) {
                return Promise.reject(new Error('Project(s) failed to build'));
            }
            else if (this._hasAnyWarnings && !this._allowWarningsInSuccessfulBuild) {
                this._terminal.writeWarningLine('Project(s) succeeded with warnings');
                return Promise.reject(new AlreadyReportedError_1.AlreadyReportedError());
            }
            else {
                return Promise.resolve();
            }
        });
    }
    /**
     * Pulls the next task with no dependencies off the build queue
     * Removes any non-ready tasks from the build queue (this should only be blocked tasks)
     */
    _getNextTask() {
        for (let i = 0; i < this._buildQueue.length; i++) {
            const task = this._buildQueue[i];
            if (task.status !== TaskStatus_1.TaskStatus.Ready) {
                // It shouldn't be on the queue, remove it
                this._buildQueue.splice(i, 1);
                // Decrement since we modified the array
                i--;
            }
            else if (task.dependencies.size === 0 && task.status === TaskStatus_1.TaskStatus.Ready) {
                // this is a task which is ready to go. remove it and return it
                return this._buildQueue.splice(i, 1)[0];
            }
            // Otherwise task is still waiting
        }
        return undefined; // There are no tasks ready to go at this time
    }
    /**
     * Helper function which finds any tasks which are available to run and begins executing them.
     * It calls the complete callback when all tasks are completed, or rejects if any task fails.
     */
    _startAvailableTasks() {
        const taskPromises = [];
        let ctask;
        while (this._currentActiveTasks < this._parallelism && (ctask = this._getNextTask())) {
            this._currentActiveTasks++;
            const task = ctask;
            task.status = TaskStatus_1.TaskStatus.Executing;
            this._terminal.writeLine(node_core_library_1.Colors.white(`[${task.name}] started`));
            task.stopwatch = Stopwatch_1.Stopwatch.start();
            task.writer = stream_collator_1.Interleaver.registerTask(task.name, this._quietMode);
            taskPromises.push(task.execute(task.writer)
                .then((result) => {
                task.stopwatch.stop();
                task.writer.close();
                this._currentActiveTasks--;
                this._completedTasks++;
                switch (result) {
                    case TaskStatus_1.TaskStatus.Success:
                        this._markTaskAsSuccess(task);
                        break;
                    case TaskStatus_1.TaskStatus.SuccessWithWarning:
                        this._hasAnyWarnings = true;
                        this._markTaskAsSuccessWithWarning(task);
                        break;
                    case TaskStatus_1.TaskStatus.Skipped:
                        this._markTaskAsSkipped(task);
                        break;
                    case TaskStatus_1.TaskStatus.Failure:
                        this._hasAnyFailures = true;
                        this._markTaskAsFailed(task);
                        break;
                }
            }).catch((error) => {
                task.writer.close();
                this._currentActiveTasks--;
                this._hasAnyFailures = true;
                task.error = error;
                this._markTaskAsFailed(task);
            }).then(() => this._startAvailableTasks()));
        }
        return Promise.all(taskPromises).then(() => { });
    }
    /**
     * Marks a task as having failed and marks each of its dependents as blocked
     */
    _markTaskAsFailed(task) {
        this._terminal.writeErrorLine(`${os.EOL}${this._getCurrentCompletedTaskString()}[${task.name}] failed to build!`);
        task.status = TaskStatus_1.TaskStatus.Failure;
        task.dependents.forEach((dependent) => {
            this._markTaskAsBlocked(dependent, task);
        });
    }
    /**
     * Marks a task and all its dependents as blocked
     */
    _markTaskAsBlocked(task, failedTask) {
        if (task.status === TaskStatus_1.TaskStatus.Ready) {
            this._completedTasks++;
            this._terminal.writeErrorLine(`${this._getCurrentCompletedTaskString()}`
                + `[${task.name}] blocked by [${failedTask.name}]!`);
            task.status = TaskStatus_1.TaskStatus.Blocked;
            task.dependents.forEach((dependent) => {
                this._markTaskAsBlocked(dependent, failedTask);
            });
        }
    }
    /**
     * Marks a task as being completed, and removes it from the dependencies list of all its dependents
     */
    _markTaskAsSuccess(task) {
        if (task.hadEmptyScript) {
            this._terminal.writeLine(node_core_library_1.Colors.green(`${this._getCurrentCompletedTaskString()}`
                + `[${task.name}] had an empty script`));
        }
        else {
            this._terminal.writeLine(node_core_library_1.Colors.green(`${this._getCurrentCompletedTaskString()}`
                + `[${task.name}] completed successfully in ${task.stopwatch.toString()}`));
        }
        task.status = TaskStatus_1.TaskStatus.Success;
        task.dependents.forEach((dependent) => {
            if (!this._changedProjectsOnly) {
                dependent.isIncrementalBuildAllowed = false;
            }
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Marks a task as being completed, but with warnings written to stderr, and removes it from the dependencies
     * list of all its dependents
     */
    _markTaskAsSuccessWithWarning(task) {
        this._terminal.writeWarningLine(`${this._getCurrentCompletedTaskString()}`
            + `[${task.name}] completed with warnings in ${task.stopwatch.toString()}`);
        task.status = TaskStatus_1.TaskStatus.SuccessWithWarning;
        task.dependents.forEach((dependent) => {
            if (!this._changedProjectsOnly) {
                dependent.isIncrementalBuildAllowed = false;
            }
            dependent.dependencies.delete(task);
        });
    }
    /**
     * Marks a task as skipped.
     */
    _markTaskAsSkipped(task) {
        this._terminal.writeLine(node_core_library_1.Colors.green(`${this._getCurrentCompletedTaskString()}[${task.name}] skipped`));
        task.status = TaskStatus_1.TaskStatus.Skipped;
        task.dependents.forEach((dependent) => {
            dependent.dependencies.delete(task);
        });
    }
    _getCurrentCompletedTaskString() {
        return `${this._completedTasks} of ${this._totalTasks}: `;
    }
    /**
     * Checks for projects that indirectly depend on themselves.
     */
    _checkForCyclicDependencies(tasks, dependencyChain) {
        for (const task of tasks) {
            if (dependencyChain.indexOf(task.name) >= 0) {
                throw new Error('A cyclic dependency was encountered:\n'
                    + '  ' + [...dependencyChain, task.name].reverse().join('\n  -> ')
                    + '\nConsider using the cyclicDependencyProjects option for rush.json.');
            }
            dependencyChain.push(task.name);
            this._checkForCyclicDependencies(task.dependents, dependencyChain);
            dependencyChain.pop();
        }
    }
    /**
     * Calculate the number of packages which must be built before we reach
     * the furthest away "root" node
     */
    _calculateCriticalPaths(task) {
        // Return the memoized value
        if (task.criticalPathLength !== undefined) {
            return task.criticalPathLength;
        }
        // If no dependents, we are in a "root"
        if (task.dependents.size === 0) {
            return task.criticalPathLength = 0;
        }
        else {
            // Otherwise we are as long as the longest package + 1
            const depsLengths = [];
            task.dependents.forEach(dep => this._calculateCriticalPaths(dep));
            return task.criticalPathLength = Math.max(...depsLengths) + 1;
        }
    }
    /**
     * Prints out a report of the status of each project
     */
    _printTaskStatus() {
        const tasksByStatus = {};
        this._tasks.forEach((task) => {
            if (tasksByStatus[task.status]) {
                tasksByStatus[task.status].push(task);
            }
            else {
                tasksByStatus[task.status] = [task];
            }
        });
        this._terminal.writeLine('');
        this._printStatus(TaskStatus_1.TaskStatus.Executing, tasksByStatus, node_core_library_1.Colors.yellow);
        this._printStatus(TaskStatus_1.TaskStatus.Ready, tasksByStatus, node_core_library_1.Colors.white);
        this._printStatus(TaskStatus_1.TaskStatus.Skipped, tasksByStatus, node_core_library_1.Colors.gray);
        this._printStatus(TaskStatus_1.TaskStatus.Success, tasksByStatus, node_core_library_1.Colors.green);
        this._printStatus(TaskStatus_1.TaskStatus.SuccessWithWarning, tasksByStatus, (text) => node_core_library_1.Colors.yellow(text), (text) => node_core_library_1.Colors.yellow(node_core_library_1.Colors.underline(text)));
        this._printStatus(TaskStatus_1.TaskStatus.Blocked, tasksByStatus, node_core_library_1.Colors.red);
        this._printStatus(TaskStatus_1.TaskStatus.Failure, tasksByStatus, node_core_library_1.Colors.red);
        const tasksWithErrors = tasksByStatus[TaskStatus_1.TaskStatus.Failure];
        if (tasksWithErrors) {
            tasksWithErrors.forEach((task) => {
                if (task.error) {
                    this._terminal.writeErrorLine(`[${task.name}] ${task.error.message}`);
                }
            });
        }
        this._terminal.writeLine('');
    }
    _printStatus(status, tasksByStatus, color, headingColor = color) {
        const tasks = tasksByStatus[status];
        if (tasks && tasks.length) {
            this._terminal.writeLine(headingColor(`${status} (${tasks.length})`));
            this._terminal.writeLine(color('================================'));
            for (let i = 0; i < tasks.length; i++) {
                const task = tasks[i];
                switch (status) {
                    case TaskStatus_1.TaskStatus.Executing:
                    case TaskStatus_1.TaskStatus.Ready:
                    case TaskStatus_1.TaskStatus.Skipped:
                        this._terminal.writeLine(color(task.name));
                        break;
                    case TaskStatus_1.TaskStatus.Success:
                    case TaskStatus_1.TaskStatus.SuccessWithWarning:
                    case TaskStatus_1.TaskStatus.Blocked:
                    case TaskStatus_1.TaskStatus.Failure:
                        if (task.stopwatch && !task.hadEmptyScript) {
                            const time = task.stopwatch.toString();
                            this._terminal.writeLine(headingColor(`${task.name} (${time})`));
                        }
                        else {
                            this._terminal.writeLine(headingColor(`${task.name}`));
                        }
                        break;
                }
                if (task.writer) {
                    const stderr = task.writer.getStdError();
                    const shouldPrintDetails = task.status === TaskStatus_1.TaskStatus.Failure || task.status === TaskStatus_1.TaskStatus.SuccessWithWarning;
                    let details = stderr ? stderr : task.writer.getStdOutput();
                    if (details && shouldPrintDetails) {
                        details = this._abridgeTaskReport(details);
                        this._terminal.writeLine(details + (i !== tasks.length - 1 ? os.EOL : ''));
                    }
                }
            }
            this._terminal.writeLine(color('================================' + os.EOL));
        }
    }
    /**
     * Remove trailing blanks, and all middle lines if text is large
     */
    _abridgeTaskReport(text) {
        const headSize = 10;
        const tailSize = 20;
        const margin = 10;
        const lines = text.split(/\s*\r?\n/).filter(line => line);
        if (lines.length < headSize + tailSize + margin) {
            return lines.join(os.EOL);
        }
        const amountRemoved = lines.length - headSize - tailSize;
        const head = lines.splice(0, headSize).join(os.EOL);
        const tail = lines.splice(-tailSize).join(os.EOL);
        return `${head}${os.EOL}[...${amountRemoved} lines omitted...]${os.EOL}${tail}`;
    }
}
exports.TaskRunner = TaskRunner;
//# sourceMappingURL=TaskRunner.js.map